/*
 * TaylorT4.cpp
 *
 *  Created on: Oct 23, 2018
 *      Author: blakemoore
 */

#include "TaylorT4.hpp"
#include "TD_PN_Amps.hpp"

double msun = 4.925502303934785*pow(10, -6);
double EulerGamma = 0.5772156649015329;
typedef boost::array< double , 4 > state_type;

TaylorT4::TaylorT4() {
	p0 = 60;
	e0 = 0.6;
	M = 20*msun;
	eta = 0.25;
	DL = 1;
	thet = 3*M_PI/7;
	psi = 3*M_PI/7;
	phi = 3*M_PI/7;
	iota = 3*M_PI/7;
	beta = 3*M_PI/7;
	sr = 8192;
	orb_pn = 3;
}
TaylorT4::TaylorT4(double p_c, double e_c, double M_c, double eta_c, double DL_c, double thet_c, double psi_c, double phi_c, double iota_c, double beta_c, int sr_c, int orb_pn_set) {
	p0 = p_c; // p0: initial semilatus rectum
	e0 = e_c; // e0: initial eccentricity
	M = M_c*msun; // Takes the Total mass in terms of Msun
	eta = eta_c; // symmetric reduced mass ratio
	DL = DL_c; // The luminosity distance
	thet = thet_c*M_PI; // Sky angles
	psi = psi_c*M_PI;
	phi = phi_c*M_PI;
	iota = iota_c*M_PI;
	beta = beta_c*M_PI;
	sr = sr_c; // The sampling rate of the time domain solution and waveform
	orb_pn = orb_pn_set; //Sets the orbital PN order (only works for the TaylorT4t version of the waveform generation)
}
TaylorT4::~TaylorT4() {
}
// Some getters for the basic inputs
double TaylorT4::get_p0(){
	return p0;
}
double TaylorT4::get_e0(){
	return e0;
}
double TaylorT4::get_M(){
	return M/msun;
}
double TaylorT4::get_eta(){
	return eta;
}
double TaylorT4::get_DL(){
	return DL;
}
double TaylorT4::get_theta(){
	return thet;
}
double TaylorT4::get_psi(){
	return psi;
}
double TaylorT4::get_phi(){
	return phi;
}
double TaylorT4::get_iota(){
	return iota;
}
double TaylorT4::get_beta(){
	return beta;
}
double TaylorT4::get_last_f(){
	return sr/2;
}
// Some of the enhancement functions which enter the waveform here given to order 50
double phie(double e)
{
return 1. + 1.51497461928934*Bpow(e,2) + \
0.12805097292724196*Bpow(e,4) + 0.00013725853073886068*Bpow(e,6) - \
0.00026661588321348*Bpow(e,8) - 1.3703362209766874e-6*Bpow(e,10) + \
1.0585006768373107e-6*Bpow(e,12) + 1.1519443597688233e-9*Bpow(e,14) - \
3.1947940783594e-9*Bpow(e,16) + 1.207952305389808e-8*Bpow(e,18) + \
1.0652695565850418e-8*Bpow(e,20) + 7.2533830784001265e-9*Bpow(e,22) + \
4.746398264907915e-9*Bpow(e,24) + 3.1222630308207083e-9*Bpow(e,26) + \
2.08724963960598e-9*Bpow(e,28) + 1.4216704949327584e-9*Bpow(e,30) + \
9.866997834687502e-10*Bpow(e,32) + 6.972505504657997e-10*Bpow(e,34) + \
5.01102213976289e-10*Bpow(e,36) + 3.658273236027318e-10*Bpow(e,38) + \
2.7097308451179447e-10*Bpow(e,40) + 2.0341995400289228e-10*Bpow(e,42) \
+ 1.546082342609773e-10*Bpow(e,44) + \
1.1886018637077374e-10*Bpow(e,46) + 9.234968907326074e-11*Bpow(e,48);
}
double zetae(double e)
{
return 1. + 4.600648781271307*Bpow(e,2) + 2.533232250638101*Bpow(e,4) \
+ 0.10758392335229243*Bpow(e,6) - 0.00019324281838476747*Bpow(e,8) - \
0.000015098595733638725*Bpow(e,10) + 2.703743862727795e-6*Bpow(e,12) \
- 3.4360444570114964e-7*Bpow(e,14) + 3.0836148721550297e-8*Bpow(e,16) \
+ 2.74182239289469e-8*Bpow(e,18) + 9.364408691547622e-9*Bpow(e,20) + \
3.4494122505486675e-9*Bpow(e,22) + 1.3779544220654485e-9*Bpow(e,24) + \
5.432526491636544e-10*Bpow(e,26) + 1.9263258785583936e-10*Bpow(e,28) \
+ 4.5991340407035493e-11*Bpow(e,30) - \
1.287457319533492e-11*Bpow(e,32) - 3.3742963356278744e-11*Bpow(e,34) \
- 3.8365952002152765e-11*Bpow(e,36) - \
3.638291728890518e-11*Bpow(e,38) - 3.2073284097070325e-11*Bpow(e,40) \
- 2.7299921774040225e-11*Bpow(e,42) - \
2.282598444166247e-11*Bpow(e,44) - 1.8916516389050032e-11*Bpow(e,46) \
- 1.5617001049510848e-11*Bpow(e,48);
}
double psie(double e)
{
return 1. - 11.115206002765259*Bpow(e,2) - \
9.511567828883182*Bpow(e,4) - 0.42360354167477193*Bpow(e,6) + \
0.005217296393502017*Bpow(e,8) - 0.00033601324589384806*Bpow(e,10) - \
0.00003129311226923878*Bpow(e,12) + 5.454312876739637e-6*Bpow(e,14) + \
2.086794410940494e-6*Bpow(e,16) + 6.440540238639287e-7*Bpow(e,18) + \
2.9342630504634106e-7*Bpow(e,20) + 1.6363858690560687e-7*Bpow(e,22) + \
9.695160971275138e-8*Bpow(e,24) + 5.934429713447774e-8*Bpow(e,26) + \
3.738148736450067e-8*Bpow(e,28) + 2.4182195801941893e-8*Bpow(e,30) + \
1.6028469698508162e-8*Bpow(e,32) + 1.0860219116387305e-8*Bpow(e,34) + \
7.505973027579471e-9*Bpow(e,36) + 5.281646099924928e-9*Bpow(e,38) + \
3.777420654881911e-9*Bpow(e,40) + 2.741846287065727e-9*Bpow(e,42) + \
2.017192984424058e-9*Bpow(e,44) + 1.5024835977653741e-9*Bpow(e,46) + \
1.1318490745383142e-9*Bpow(e,48);
}
double kappae(double e){
	return -2677.585253811666 - 35437.14797821146*Bpow(e,2) - 63324.73802240542*Bpow(e,4) -
			   38173.47134580091*Bpow(e,6) - 22111.93625254929*Bpow(e,8) -
			   15872.94730579853*Bpow(e,10) - 12450.071507453918*Bpow(e,12) -
			   10259.745861053467*Bpow(e,14) - 8731.815933227539*Bpow(e,16) -
			   7603.127380371094*Bpow(e,18) - 6734.41015625*Bpow(e,20) -
			   6044.7197265625*Bpow(e,22) - 5483.68359375*Bpow(e,24) - 5018.26171875*Bpow(e,26) -
			   4625.875*Bpow(e,28) - 4290.375*Bpow(e,30) - 4000.25*Bpow(e,32) - 3748.*Bpow(e,34) -
			   3524.*Bpow(e,36) - 3328.*Bpow(e,38) - 3168.*Bpow(e,40) - 3040.*Bpow(e,42) -
			   2944.*Bpow(e,44) - 2816.*Bpow(e,46) - 1024.*Bpow(e,48);
}
double phiy(double e)
{
return 1. + 3.03125*Bpow(e,2) + 0.3828125*Bpow(e,4) - \
0.002658420138888889*Bpow(e,6) - 0.0007392035590277778*Bpow(e,8) - \
0.00004352145724826389*Bpow(e,10) + 6.5683435510706014e-6*Bpow(e,12) \
+ 1.8869713230378142e-6*Bpow(e,14) + 5.340116447211814e-7*Bpow(e,16) \
+ 2.6614023845421447e-7*Bpow(e,18) + 1.6758031878129002e-7*Bpow(e,20) \
+ 1.1072246746386881e-7*Bpow(e,22) + 7.471822488054135e-8*Bpow(e,24) \
+ 5.146020329960196e-8*Bpow(e,26) + 3.6177685189754746e-8*Bpow(e,28) \
+ 2.5940306037790555e-8*Bpow(e,30) + 1.8945094529252664e-8*Bpow(e,32) \
+ 1.4072371670990607e-8*Bpow(e,34) + 1.0616000102829527e-8*Bpow(e,36) \
+ 8.122592992948808e-9*Bpow(e,38) + 6.2956178645912885e-9*Bpow(e,40) \
+ 4.937590644779469e-9*Bpow(e,42) + 3.914698590415e-9*Bpow(e,44) + \
3.1347814319768067e-9*Bpow(e,46) + 2.5333885608360962e-9*Bpow(e,48) + \
2.064799404249423e-9*Bpow(e,50);
}
double zetay(double e)
{
return 1. + 9.490383807844125*Bpow(e,2) + 7.920161197194927*Bpow(e,4) \
+ 0.44297647042356036*Bpow(e,6) - 0.0009687994737718476*Bpow(e,8) - \
0.00017211031253207732*Bpow(e,10) + \
0.000030611825729665384*Bpow(e,12) - 1.4588927532894898e-6*Bpow(e,14) \
- 2.5845382782563615e-7*Bpow(e,16) + 1.4883989682931052e-7*Bpow(e,18) \
+ 8.217675414452639e-8*Bpow(e,20) + 3.2098947950317565e-8*Bpow(e,22) \
+ 1.147454845702686e-8*Bpow(e,24) + 3.2362498229659846e-9*Bpow(e,26) \
- 6.417222119913884e-11*Bpow(e,28) - 1.303301030626863e-9*Bpow(e,30) \
- 1.6630263511426093e-9*Bpow(e,32) - 1.654518007464746e-9*Bpow(e,34) \
- 1.5041255221088099e-9*Bpow(e,36) - 1.3120275099847213e-9*Bpow(e,38) \
- 1.121198981921691e-9*Bpow(e,40) - 9.484608903105266e-10*Bpow(e,42) \
- 7.987855373192914e-10*Bpow(e,44) - 6.71975414221337e-10*Bpow(e,46) \
- 5.657871223039995e-10*Bpow(e,48) - \
4.773716092223972e-10*Bpow(e,50);
}
double psiy(double e)
{
return 1. - 24.966458283241163*Bpow(e,2) - 31.493707171195*Bpow(e,4) \
- 1.7610755874141755*Bpow(e,6) + 0.03285966425618972*Bpow(e,8) - \
0.0024835514403794647*Bpow(e,10) - 0.0003645121842848611*Bpow(e,12) + \
0.000028439718336146327*Bpow(e,14) + \
0.000026215455369779352*Bpow(e,16) + \
0.000011284471514057857*Bpow(e,18) + 5.413765521696259e-6*Bpow(e,20) \
+ 2.9844473457254302e-6*Bpow(e,22) + 1.7875388388482788e-6*Bpow(e,24) \
+ 1.1267904610440866e-6*Bpow(e,26) + 7.369623193951236e-7*Bpow(e,28) \
+ 4.964094620640843e-7*Bpow(e,30) + 3.427498181002189e-7*Bpow(e,32) + \
2.4175344555332836e-7*Bpow(e,34) + 1.737292699607041e-7*Bpow(e,36) + \
1.2692425399097711e-7*Bpow(e,38) + 9.410489432677677e-8*Bpow(e,40) + \
7.070014830818224e-8*Bpow(e,42) + 5.3753589770395885e-8*Bpow(e,44) + \
4.131307845594878e-8*Bpow(e,46) + 3.206535285051507e-8*Bpow(e,48) + \
2.51118787904475e-8*Bpow(e,50);
}
double kappay(double e){
	return -97.834874089724*Bpow(e,2) - 305.40437199581993*Bpow(e,4) -
			   211.85079322471574*Bpow(e,6) - 116.34355627186596*Bpow(e,8) -
			   81.6298772020964*Bpow(e,10) - 63.25489540491253*Bpow(e,12) -
			   51.729661805555224*Bpow(e,14) - 43.79285129904747*Bpow(e,16) -
			   37.98345610499382*Bpow(e,18) - 33.5427211523056*Bpow(e,20) -
			   30.0359206199646*Bpow(e,22) - 27.195453643798828*Bpow(e,24) -
			   24.84735107421875*Bpow(e,26) - 22.873458862304688*Bpow(e,28) -
			   21.1907958984375*Bpow(e,30) - 19.7391357421875*Bpow(e,32) -
			   18.4736328125*Bpow(e,34) - 17.3642578125*Bpow(e,36) - 16.37890625*Bpow(e,38) -
			   15.4765625*Bpow(e,40) - 14.71875*Bpow(e,42) - 14.*Bpow(e,44) - 13.5*Bpow(e,46) -
			   12.25*Bpow(e,48) - 17.*Bpow(e,50);
}

////////////////////////////////////////////////////////////////////////////////////////
// The 3PN accurate ODEs for orbital dynamics in terms of time derivatives
////////////////////////////////////////////////////////////////////////////////////////

double TaylorT4::edot(double y, double e){
	vector<double> pn (7);
	double newt;
	double tot = 0;

	newt = -Bpow(1 - e*e, 3./2.)/(2*e)*eta*Bpow(y,8);
	pn[0] = (608*Bpow(e,2))/15. + (242*Bpow(e,4))/15.;
	pn[1] = 0;
	pn[2] = (-53.65714285714286 - (8168*eta)/45.)*Bpow(e,2) + (569.847619047619 - (7753*eta)/15.)*Bpow(e,4) + (99.49285714285715 - (3328*eta)/45.)*Bpow(e,6);
	pn[3] = (788*M_PI*Bpow(e,2))/3.*phie(e);
	pn[4] = Bpow(e,8)*(250.4327380952381 - (362071*eta)/1260. + (1642*Bpow(eta,2))/9.) + Bpow(e,2)*(-1007.8275132275132 + (5937*eta)/7. + (1504*Bpow(eta,2))/5.) +
			   Bpow(e,6)*(3079.76917989418 - (13057267*eta)/2520. + (127411*Bpow(eta,2))/45.) + Bpow(e,4)*(-2471.419841269841 - (388419*eta)/140. + (64433*Bpow(eta,2))/20.) +
			   ((890.6666666666666 - (5344*eta)/15.)*Bpow(e,2) + (2321 - (4642*eta)/5.)*Bpow(e,4) + (188.33333333333334 - (226*eta)/3.)*Bpow(e,6))*Bpow(1 - Bpow(e,2),0.5);
	pn[5] = M_PI*((-610144*eta)/315.*zetae(e) - (55691)/105.*psie(e))*Bpow(e,2);
	pn[6] = 0.27174603174603174*kappae(e)*Bpow(e,2) + Bpow(e,6)*(-12323.76643050843 + 16360.658235464523*eta + 34916.885615079365*Bpow(eta,2) -
		      24702.67777777778*Bpow(eta,3)) + Bpow(e,8)*(9637.116821122356 - 18419.10421223781*eta + 19805.325396825396*Bpow(eta,2) -
		      9705.40658436214*Bpow(eta,3)) + Bpow(e,4)*(18966.888513123078 + 59511.29936669912*eta - 10703.091402116403*Bpow(eta,2) -
		      8941.410390946503*Bpow(eta,3)) + Bpow(e,10)*(340.82134852994227 - 381.22757936507935*eta + 381.287037037037*Bpow(eta,2) -
		      318.34732510288063*Bpow(eta,3)) + Bpow(e,2)*(18554.153440943162 + 2772.6686639293707*eta - 3292.775396825397*Bpow(eta,2) -
		      251.03292181069958*Bpow(eta,3)) + 61.81316402116402*(1. - 1.*Bpow(1. - 1.*Bpow(e,2),0.5)) +
		   (Bpow(e,8)*(1112.8630952380952 - 1149.5674603174602*eta + 355.22222222222223*Bpow(eta,2)) +
		      Bpow(e,2)*(-2884.1966984126984 - 10784.616367176932*eta + 2414.7555555555555*Bpow(eta,2)) +
		      Bpow(e,6)*(28155.796894179894 - 35007.07931571595*eta + 10004.711111111112*Bpow(eta,2)) +
		      Bpow(e,4)*(22703.66653968254 - 58850.161467528844*eta + 15155.31111111111*Bpow(eta,2)))*Bpow(1. - 1.*Bpow(e,2),0.5) +
		   (1671.7815873015873*Bpow(e,2) + 6047.9796825396825*Bpow(e,4) + 2913.3892063492062*Bpow(e,6) + 116.78285714285714*Bpow(e,8))*
		    log(0.125*Bpow(y,-1)*Bpow(1. - 1.*Bpow(e,2),-1.5)*(1. + Bpow(1. - 1.*Bpow(e,2),0.5)));

	for( int i = 0; i <= orb_pn*2; i++ ){
		tot += newt*pn[i]*pow(y, (double) i);
	}
	return tot;
}
double TaylorT4::ydot(double y, double e){
	vector<double> pn (7);
	double newt;
	double tot = 0;

	newt = eta*pow(y,9)*pow(1 - pow(e,2),1.5);
	pn[0] = 6.4 + (28*pow(e,2))/5.;
	pn[1] = 0;
	pn[2] = -14.152380952380952 - (88*eta)/5. + (117.1047619047619 - (5258*eta)/45.)*pow(e,2) + (35.79761904761905 - (244*eta)/9.)*pow(e,4);
	pn[3] = (128*M_PI)/5.*phiy(e);
	pn[4] = 12.029276895943562 + (13661*eta)/315. + (944*pow(eta,2))/45. + pow(e,6)*(21.381349206349206 - (7357*eta)/90. + (9392*pow(eta,2))/135.) +
			   pow(e,2)*(-271.66455026455026 - (173587*eta)/315. + (147443*pow(eta,2))/270.) + pow(e,4)*(277.18478835978834 - (589507*eta)/504. + (34679*pow(eta,2))/45.) +
			   (14.166666666666666 + (1445*eta)/6.)*pow(e,2)*pow(1 - pow(e,2),-1) + (16 - (32*eta)/5. + (266 - (532*eta)/5.)*pow(e,2) + (-429.5 + (859*eta)/5.)*pow(e,4) + (-65 + 26*eta)*pow(e,6))*pow(1 - pow(e,2),-0.5)*
			    (1 - pow(1 - pow(e,2),0.5));
	pn[5] = M_PI*((-756*eta)/5.*zetay(e) - (4159)/105.*psiy(e));
	pn[6] = 1030.0945216480031 - 1058.4386822731644*eta + 7.337142857142857*kappay(e) + 3.8642857142857143*Bpow(eta,2) +
			   Bpow(e,4)*(-2651.5956147372017 + 5987.218639654549*eta + 7295.625165343916*Bpow(eta,2) - 5427.683950617284*Bpow(eta,3)) +
			   Bpow(e,6)*(-4395.717593804625 + 3501.934749964526*eta + 3410.020502645503*Bpow(eta,2) - 2955.866666666667*Bpow(eta,3)) +
			   Bpow(e,2)*(4815.516772425437 - 2980.0462639414045*eta + 3399.6920634920634*Bpow(eta,2) - 1212.7932098765432*Bpow(eta,3)) +
			   Bpow(e,8)*(-274.52094268578645 + 276.4234788359788*eta + 22.143121693121692*Bpow(eta,2) - 125.06666666666666*Bpow(eta,3)) -
			   13.839506172839506*Bpow(eta,3) + (-422.3167407407407 + 17.85757239787629*eta +
			      Bpow(e,6)*(-6642.266626984127 + 8469.577424156345*eta - 2422.6111111111113*Bpow(eta,2)) +
			      Bpow(e,4)*(1991.5945238095237 + 2684.9618536999524*eta - 527.1444444444444*Bpow(eta,2)) +
			      Bpow(e,8)*(-388.5654761904762 + 405.0484126984127*eta - 124.95555555555555*Bpow(eta,2)) + 42.13333333333333*Bpow(eta,2) +
			      Bpow(e,2)*(2271.8352380952383 - 5920.424974781387*eta + 1576.5777777777778*Bpow(eta,2)))*Bpow(1. - 1.*Bpow(e,2),-0.5)*
			    (1. - 1.*Bpow(1. - 1.*Bpow(e,2),0.5)) + Bpow(e,2)*Bpow(1. - 1.*Bpow(e,2),-1)*
			    (241.49408201058202 + 3136.0031329864396*eta - 4047.4166666666665*Bpow(eta,2) - 30.90658201058201*Bpow(1. + Bpow(1. - 1.*Bpow(e,2),0.5),-1)) +
			   (104.35047619047619 + 746.7580952380953*Bpow(e,2) + 533.1657142857143*Bpow(e,4) + 28.125714285714285*Bpow(e,6))*
			    log(0.125*Bpow(y,-1)*Bpow(1. - 1.*Bpow(e,2),-1.5)*(1. + Bpow(1. - 1.*Bpow(e,2),0.5)));

	for( int i = 0; i <= orb_pn*2; i++ ){
		tot += newt*pn[i]*pow(y, (double) i);
	}
	return tot;
}
double TaylorT4::lamdot(double y, double e){
	return Bpow(y,3)*Bpow(1 - Bpow(e,2),1.5);
}
double TaylorT4::ldot(double y, double e){
	vector<double> pn (7);
	double newt;
	double tot = 0;

	newt = Bpow(y,3)*Bpow(1 - Bpow(e,2),1.5);
	pn[0] = 1.;
	pn[1] = 0;
	pn[2] = -3.;
	pn[3] = 0;
	pn[4] = (-18 + 28*eta - (51 - 26*eta)*Bpow(e,2))/4.;
	pn[5] = 0;
	pn[6] = (192 - 896*Bpow(eta,2) - Bpow(e,4)*(2496 - 1760*eta + 1040*Bpow(eta,2)) - Bpow(e,2)*(8544 + 5120*Bpow(eta,2) - eta*(17856 - 123*Bpow(M_PI,2))) + eta*(14624 - 492*Bpow(M_PI,2)) -
		     (1920 - 768*eta + (3840 - 1536*eta)*Bpow(e,2))*Bpow(1 - Bpow(e,2),0.5))/128.;

	for( int i = 0; i <= orb_pn*2; i++ ){
		tot += newt*pn[i]*pow(y, (double) i);
	}
	return tot;
}

////////////////////////////////////////////////////////////////////////////////////////
// The 3PN accurate ODEs for orbital dynamics in terms of eccentricity derivatives
////////////////////////////////////////////////////////////////////////////////////////

double TaylorT4::dyde_6(double y, double e)
{
return -1.*y*Bpow(e,-1)*Bpow(1. - \
1.*Bpow(e,2),-1.5)*Bpow(2.512396694214876 + 1.*Bpow(e,2),-4)*Bpow(1. \
+ Bpow(1. - 1.*Bpow(e,2),0.5),-1)*(12.582023807075203 - \
11.166940302457407*Bpow(y,2) + 21.74262008766506*eta*Bpow(y,2) - \
98.03883402611149*Bpow(y,3) + 45.23440515004199*Bpow(y,4) - \
88.64865749713489*eta*Bpow(y,4) + \
45.234195700682605*Bpow(eta,2)*Bpow(y,4) + \
370.1530485161277*Bpow(y,5) + 73.39584176937029*eta*Bpow(y,5) - \
589.6598545957606*Bpow(y,6) + 689.7449410176819*eta*Bpow(y,6) - \
9.723883770694399e-17*Bpow(e,106)*Bpow(y,6) - \
237.92870518338333*Bpow(eta,2)*Bpow(y,6) + \
91.92469298873282*Bpow(eta,3)*Bpow(y,6) + \
Bpow(e,62)*Bpow(y,5)*(-1.2695253834100954e-7 + \
9.436703067755226e-8*eta + y*(-1.3468856381527323e-7 - \
1.289486550717187e-9*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,64)*Bpow(y,6)*(1.009897634524955e-9 - \
2.7958891619223205e-10*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,104)*Bpow(y,6)*(-5.230975247620953e-16 + \
9.723883770694404e-17*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,102)*Bpow(y,6)*(-8.717196982339231e-16 + \
6.203363624690394e-16*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,100)*Bpow(y,6)*(-6.933191125179409e-16 + \
1.492056060702963e-15*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,98)*Bpow(y,6)*(-1.0415599125485032e-15 + \
2.1853751732209038e-15*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,96)*Bpow(y,6)*(-1.5104138771037125e-15 + \
3.2269350857694072e-15*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,94)*Bpow(y,6)*(-2.201118837058145e-15 + \
4.73734896287312e-15*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,92)*Bpow(y,6)*(-3.2281322154405526e-15 + \
6.9384677999312655e-15*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,90)*Bpow(y,6)*(-4.77118311230351e-15 + \
1.0166600015371815e-14*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,88)*Bpow(y,6)*(-7.11629900018726e-15 + \
1.493778312767533e-14*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,86)*Bpow(y,6)*(-1.0724388553894806e-14 + \
2.2054082127862588e-14*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,84)*Bpow(y,6)*(-1.6344789549906725e-14 + \
3.27784706817574e-14*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,82)*Bpow(y,6)*(-2.5192906891249145e-14 + \
4.912326023166413e-14*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,80)*Bpow(y,6)*(-3.915899418164118e-14 + \
7.431616712291328e-14*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,78)*Bpow(y,6)*(-6.05663286829679e-14 + \
1.1347516130455448e-13*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,76)*Bpow(y,6)*(-8.8194290172625e-14 + \
1.7404148998752237e-13*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,74)*Bpow(y,6)*(-9.753818810691094e-14 + \
2.622357801601473e-13*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,72)*Bpow(y,6)*(-7.405112115984818e-14 + \
3.5977396826705825e-13*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,70)*Bpow(y,6)*(-1.319710190323463e-12 + \
4.3382508942690645e-13*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,68)*Bpow(y,6)*(-3.770858123572004e-12 + \
1.7535352797503693e-12*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,66)*Bpow(y,6)*(2.8511330959555446e-10 + \
5.524393403322374e-12*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
12.582023807075203*Bpow(1. - 1.*Bpow(e,2),0.5) - \
11.166940302457407*Bpow(y,2)*Bpow(1. - 1.*Bpow(e,2),0.5) + \
21.742620087665046*eta*Bpow(y,2)*Bpow(1. - 1.*Bpow(e,2),0.5) - \
98.03883402611149*Bpow(y,3)*Bpow(1. - 1.*Bpow(e,2),0.5) + \
45.234405150042015*Bpow(y,4)*Bpow(1. - 1.*Bpow(e,2),0.5) - \
88.64865749713488*eta*Bpow(y,4)*Bpow(1. - 1.*Bpow(e,2),0.5) + \
45.23419570068261*Bpow(eta,2)*Bpow(y,4)*Bpow(1. - 1.*Bpow(e,2),0.5) + \
370.1530485161277*Bpow(y,5)*Bpow(1. - 1.*Bpow(e,2),0.5) + \
73.3958417693703*eta*Bpow(y,5)*Bpow(1. - 1.*Bpow(e,2),0.5) - \
608.8473883450595*Bpow(y,6)*Bpow(1. - 1.*Bpow(e,2),0.5) + \
689.7449410176814*eta*Bpow(y,6)*Bpow(1. - 1.*Bpow(e,2),0.5) - \
237.92870518338304*Bpow(eta,2)*Bpow(y,6)*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ 91.92469298873283*Bpow(eta,3)*Bpow(y,6)*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ Bpow(e,22)*Bpow(y,3)*(0.00011925025465347349 + \
Bpow(y,3)*(33.388626059107494 - 105.77788974169712*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 0.0000629252859055358*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(0.0033146591111682536 - \
0.0003153214583216144*eta + 0.004614788467097878*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.0017909830411510117*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,20)*Bpow(y,3)*(-0.00017526343294477152 + \
Bpow(y,3)*(53.18082452231764 - 139.16651580080463*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 0.0001821755405590095*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(0.04820469860782998 - \
0.009345810868587188*eta + 0.0013001293559296247*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.0014756615828293974*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,24)*Bpow(y,3)*(0.000038288354548149266 + \
Bpow(y,3)*(22.48754004571188 - 83.29034969598524*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 0.000024636931357386544*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-0.0025066493362068194 + \
0.0012381815749543453*eta + 0.0021081391308910595*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.0005528014661966667*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,26)*Bpow(y,3)*(0.00001119107431134396 + \
Bpow(y,3)*(15.923505090799702 - 67.36684460518558*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 0.000013445857046042573*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-0.0011343221821264885 + \
0.00032840402240151393*eta + 0.0009738169487645713*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.0002243974437951527*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,28)*Bpow(y,3)*(4.996103707486274e-6 + \
Bpow(y,3)*(11.714384786482752 - 55.652459818702816*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 8.449753338556304e-6*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ Bpow(y,2)*(-0.0004506905072633745 + 0.00008972005220560085*eta + \
0.0005231264415011966*Bpow(1. - 1.*Bpow(e,2),0.5) - \
0.00013467739158955187*eta*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,30)*Bpow(y,3)*(2.8973447547892358e-6 + \
Bpow(y,3)*(8.87772542988553 - 46.77473438881728*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 5.552408583767069e-6*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ Bpow(y,2)*(-0.00021305723339483002 + 0.00004436396806338016*eta + \
0.00031006920810636656*Bpow(1. - 1.*Bpow(e,2),0.5) - \
0.00009031342352617174*eta*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,32)*Bpow(y,3)*(1.813961755704169e-6 + \
Bpow(y,3)*(6.915278840439491 - 39.8594555483778*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 3.7384468280629033e-6*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-0.00011587451208890975 + \
0.0000284068031637158*eta + 0.00019419469601745682*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.00006190662036245594*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,34)*Bpow(y,3)*(1.168524741149872e-6 + \
Bpow(y,3)*(5.411604780146383 - 34.44785076823141*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 2.5699220869130295e-6*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-0.00006803949904310826 + \
0.000018891447183970876*eta + 0.00012615519697434856*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.00004301517317848506*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,36)*Bpow(y,3)*(7.687845291855693e-7 + \
Bpow(y,3)*(4.41650227469101 - 30.031348493540406*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 1.8011375577274585e-6*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-0.00004183663610730532 + \
0.000012683788397896721*eta + 0.00008431856086704327*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.00003033138478058834*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,38)*Bpow(y,3)*(5.15890519712472e-7 + \
Bpow(y,3)*(3.8572428252547897 - 26.174105668285605*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 1.2852470380149882e-6*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-0.000026600122942309964 + \
8.616569430808225e-6*eta + 0.00005771843792473327*Bpow(1. - \
1.*Bpow(e,2),0.5) - 0.000021714815349780116*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,40)*Bpow(y,3)*(3.5275813264602154e-7 + \
Bpow(y,3)*(5.701553515131375 - 20.472552153154236*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 9.324889053689669e-7*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ Bpow(y,2)*(-0.000017379163502444627 + 5.936047234122917e-6*eta + \
0.000040339274422288666*Bpow(1. - 1.*Bpow(e,2),0.5) - \
0.0000157787681156572*eta*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,42)*Bpow(y,3)*(2.455102823882015e-7 + \
Bpow(y,3)*(2.3270585194517714 - 18.14549363370247*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 6.869786229807654e-7*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ Bpow(y,2)*(-0.000011622800490734138 + 4.149827770016409e-6*eta + \
0.00002871647393155452*Bpow(1. - 1.*Bpow(e,2),0.5) - \
0.000011628940345640792*eta*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,44)*Bpow(y,3)*(1.7370420374216744e-7 + \
Bpow(y,3)*(-10.219295555349088 - 28.364789189051553*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 5.13274419238598e-7*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ Bpow(y,2)*(-7.934438308003247e-6 + 2.9434923513072944e-6*eta + \
0.000020782035623551277*Bpow(1. - 1.*Bpow(e,2),0.5) - \
8.685447994333496e-6*eta*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,54)*Bpow(y,3)*(1.1428744683925509e-8 - \
4.0986893855050293e-7*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,3)*(134.1567717593462 + 11.80900893316305*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,2)*(2.6769761545145e-6 - \
2.3596030534506476e-6*eta + 0.000012907256689351351*Bpow(1. - \
1.*Bpow(e,2),0.5) - 6.6555223859059435e-6*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,46)*Bpow(y,3)*(1.24790462718315e-7 + \
Bpow(y,3)*(-23.370268164123964 - 51.73505735317552*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 3.8848395652028326e-7*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-5.5168837969174686e-6 + \
2.1171894740244894e-6*eta + 0.000015265151826633805*Bpow(1. - \
1.*Bpow(e,2),0.5) - 6.568258520309007e-6*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,48)*Bpow(y,3)*(9.09270148600391e-8 + \
Bpow(y,3)*(-35.18991936786552 - 86.92497672104099*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 2.9755694166024396e-7*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-3.899983220276207e-6 + \
1.5431648549365128e-6*eta + 0.000011365168606357599*Bpow(1. - \
1.*Bpow(e,2),0.5) - 5.025093665372495e-6*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,56)*Bpow(y,3)*(2.5331506403208104e-7 - \
1.565538745184219e-7*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,3)*(27.21497487275918 + 39.02398380592224*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,2)*(-5.439298091322634e-6 + \
2.192429669594758e-6*eta + 7.467958598028718e-6*Bpow(1. - \
1.*Bpow(e,2),0.5) - 4.463092716311185e-6*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,52)*Bpow(y,3)*(-2.094271842388048e-7 + \
Bpow(y,3)*(24.205781026260023 - 122.34776282618317*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 4.2129768323442866e-7*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(2.1013944058866388e-6 - \
5.492538635650472e-7*eta + 0.00001023028053483685*Bpow(1. - \
1.*Bpow(e,2),0.5) - 4.2959193324552955e-6*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,50)*Bpow(y,3)*(8.568644266462041e-8 + \
Bpow(y,3)*(-59.62856713140219 - 146.5535438524432*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 2.118704989956236e-7*Bpow(1. - 1.*Bpow(e,2),0.5) \
+ Bpow(y,2)*(-3.236282477407387e-6 + 1.2784281964822465e-6*eta + \
8.128886128950212e-6*Bpow(1. - 1.*Bpow(e,2),0.5) - \
3.7466654688902483e-6*eta*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,58)*Bpow(y,3)*(1.359677975136434e-7 - \
2.0586077004778534e-8*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,3)*(-30.098361693414276 + 8.925622112507934*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,2)*(-5.706218911338173e-6 + \
3.294059894175913e-6*eta + 1.7617396866905449e-6*Bpow(1. - \
1.*Bpow(e,2),0.5) - 1.169032822135271e-6*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,60)*(2.0586077004778534e-8*Bpow(y,3) + \
Bpow(y,6)*(-8.925621979108858 + 1.3339907726455608e-7*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,5)*(-1.6347871483495353e-6 + \
1.0746657914577186e-6*eta + 1.2695253834100954e-7*Bpow(1. - \
1.*Bpow(e,2),0.5) - 9.43670306775523e-8*eta*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(e,18)*Bpow(y,3)*(-0.00011265067349019036 + \
Bpow(y,3)*(97.91097002931292 - 3.8176483142920024*eta + \
0.9453645997067638*Bpow(eta,2) + 0.008619646497315616*Bpow(eta,3) - \
192.34734032312224*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
6.912107614238051e-6*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,2)*(0.16142825115972578 - 0.07406242000433903*eta - \
0.0469045692519004*Bpow(1. - 1.*Bpow(e,2),0.5) + \
0.00787014928575779*eta*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(e,16)*Bpow(y,3)*(-0.03550622625075125 + y*(-1.033135795321515 + \
0.8272079310415003*eta - 0.044769305463122945*Bpow(eta,2)) + \
Bpow(y,2)*(1.170700350708588 + eta*(-1.619460144739793 + \
0.0819325692900968*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
0.2083328204116261*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
0.00010573856587595225*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,3)*(228.8727604443367 + Bpow(eta,2)*(3.2487175196452367 - \
1.489518785384437*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(eta,3)*(2.735455126769587 - 0.008619646497315614*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 291.51864874286355*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-34.62051898441732 + 5.5614465064217455*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,2)*(0.8691529603571676 + \
Bpow(y,3)*(48.04765138191603 - 49.991182644195526*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 13.451176767432367*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,2)*(70.2777242805256 + eta*(-59.916430458818546 - \
38.17381037115352*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
59.110783978068184*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,5)*(702.3391575026232 + eta*(-175.92330108848452 - \
102.52745931911416*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
1072.492206018751*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,6)*(-1854.8480850687424 + eta*(232.9285372307094 - \
916.7189170222937*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(eta,3)*(-151.05034100681286 - 59.12564801808003*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 2504.2118859613774*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(267.60301273644336 + 66.42125243004966*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,4)*(-203.19177353965483 + \
87.06098995869364*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(41.20102922579118 + 86.43522492647377*Bpow(1. - \
1.*Bpow(e,2),0.5)) + eta*(304.19276373918257 + \
117.53676290272516*Bpow(1. - 1.*Bpow(e,2),0.5)))) + \
Bpow(e,14)*Bpow(y,2)*(0.15655888063851997 - 0.17858525146278723*eta + \
y*(-0.9209558654266016 + 0.03561196481662719*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,2)*(-13.497372251936248 + \
eta*(11.148122643480036 - 0.8087665677466425*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(eta,2)*(-3.8847237492758184 + \
0.04476930546312295*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
0.9870323870843729*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,3)*(-13.860063024037833 - 1.3790331711202144*Bpow(1. - \
1.*Bpow(e,2),0.5) + eta*(49.050600437485805 + \
1.7013927140298895*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(y,4)*(636.206675997447 + Bpow(eta,2)*(520.8335070735413 - \
43.07067519676694*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(eta,3)*(-188.91399877717404 - 2.7440747732669024*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 601.0072831987493*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-889.8284684655171 + 161.90429944091176*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,12)*(0.6942148760330581 + \
Bpow(y,2)*(-3.273219373035583 + eta*(2.408704338527809 + \
0.17858525146278714*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
0.15655888063851997*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,3)*(-21.509019001751813 + 0.9565678302432289*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,5)*(575.5585025193651 + \
eta*(-183.88752868864177 - 47.3492077234559*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 12.481029852917619*Bpow(1. - 1.*Bpow(e,2),0.5)) \
+ Bpow(y,4)*(79.2872412957802 + eta*(-140.7294140320245 - \
0.8660010058530012*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
13.242815874413576*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(61.841478596510036 + 3.92949305473894*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,6)*(-2294.6378730748106 + \
Bpow(eta,2)*(-3476.2583573401243 - 345.2289127511523*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 292.40755213585965*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,3)*(1076.392817694048 + 186.169924003907*Bpow(1. - \
1.*Bpow(e,2),0.5)) + eta*(3560.4421117529737 + \
423.5169648835914*Bpow(1. - 1.*Bpow(e,2),0.5)))) + \
Bpow(e,10)*(4.6373881565466855 - 0.6942148760330581*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,2)*(-2.757985165174609 + \
eta*(4.063472297500316 - 2.230119087065023*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 3.1166604923970613*Bpow(1. - 1.*Bpow(e,2),0.5)) \
+ Bpow(y,3)*(-66.60111557796115 + 22.465586831995047*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,5)*(476.3509390292458 - \
563.0774726664478*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(43.43024305499383 + 136.53832096518582*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,4)*(-0.12726967084074658 + \
Bpow(eta,2)*(2.06962431226102 - 57.91198554177105*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 145.9756265305787*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(6.726446435572288 + 161.24164077032552*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,6)*(3642.920638517198 + \
eta*(-15585.862895815166 - 2290.031040278489*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(eta,3)*(-2427.968519914059 - \
890.2228936901411*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
2335.505038730418*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(11655.58320926275 + 3190.9000411984443*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,4)*(-20.358519412125496 + \
Bpow(y,3)*(5.71417029274366 - 44.27701235145179*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 6.907342644693124*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,2)*(-87.23161324689208 - 28.120829268823893*Bpow(1. - \
1.*Bpow(e,2),0.5) + eta*(49.804972412907254 + \
11.63116204175371*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(y,5)*(-1708.0905633165091 - 635.5983572977569*Bpow(1. - \
1.*Bpow(e,2),0.5) + eta*(1006.5775223216895 + \
904.0500630025742*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(y,4)*(-773.6265592940711 + Bpow(eta,2)*(-288.35718724328376 - \
201.92196231680998*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
586.090180121156*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(1278.1661115723118 + 1355.5127187893484*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,6)*(-1875.2625304316398 + \
Bpow(eta,2)*(-3590.3847293548715 - 3332.0290537801848*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 3764.1550323189986*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,3)*(319.8564671489711 + 260.7308191308912*Bpow(1. - \
1.*Bpow(e,2),0.5)) + eta*(6275.430205379507 + \
3675.7024591357167*Bpow(1. - 1.*Bpow(e,2),0.5)))) + \
Bpow(e,6)*(-6.192697376508514 - 13.100040021201641*Bpow(1. - \
1.*Bpow(e,2),0.5) + Bpow(y,3)*(124.05978412923142 + \
79.7827717777796*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,5)*(1420.2001355830198 + eta*(-1963.052401126481 - \
1059.0023381239064*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
784.6017782852626*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,2)*(-0.5369324072931754 - 28.65776167611707*Bpow(1. - \
1.*Bpow(e,2),0.5) + eta*(1.5139914201486497 + \
13.145153461902359*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(y,4)*(1024.3143859754073 + eta*(-1601.9967328368882 - \
316.8050349899852*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
614.0267582103634*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(386.09383704206476 + 184.17187472525472*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,6)*(11976.83476148948 + \
eta*(-13604.405144524753 - 14164.5765091924*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(eta,3)*(-1385.2006453503511 - \
1124.4698262194597*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
11873.292421680435*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(7905.469384318721 + 5856.999109382252*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,8)*(7.768436988621904 - \
5.331603032579746*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(y,2)*(34.53240733368875 + eta*(-19.438744846467696 - \
6.293591384565339*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
5.87464565757167*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,3)*(9.283930632176624 + 89.06670240995625*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(y,4)*(-157.35992186940504 + \
Bpow(eta,2)*(-244.15348457928664 - 59.98160985403207*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 74.09936436390477*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(230.31415204445997 + 66.53610584529608*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,5)*(-1824.0301899809565 - \
1039.4284116956937*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(1152.1104160340985 + 93.10807791019197*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,6)*(-10160.68480362994 + \
Bpow(eta,2)*(-13049.111403632434 - 9263.969624686613*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 4606.5755039341075*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,3)*(2662.215452443378 + 1537.7456262239193*Bpow(1. - \
1.*Bpow(e,2),0.5)) + eta*(19359.988880723293 + \
16241.911394348715*Bpow(1. - 1.*Bpow(e,2),0.5)))) + \
Bpow(y,6)*(-313.79378171480045 - 1.538489759676835*Bpow(e,16) + \
Bpow(e,2)*(-403.9096020493649 - 717.703383764165*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(e,4)*(162.67685720138545 - \
555.0265265627795*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
313.7937817148003*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(e,14)*(-60.9045410879364 + 1.5384897596768359*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(e,12)*(-310.8212055096252 + \
62.44303084761323*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,10)*(-396.41323345030844 + 373.26423635723825*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(e,6)*(934.6269918324489 + \
379.60046526966903*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(e,8)*(390.07700453787777 + 769.6774698075467*Bpow(1. - \
1.*Bpow(e,2),0.5)))*log(Bpow(y,-1)*(0.125*Bpow(1. - \
1.*Bpow(e,2),-1.5) + 0.125*Bpow(1. - 1.*Bpow(e,2),-1))));
}
double TaylorT4::dtde_6(double y, double e)
{
return -1.*M*Bpow(e,-3)*Bpow(eta,-1)*Bpow(y,-8)*Bpow(1. - \
1.*Bpow(e,2),-1.5)*Bpow(2.512396694214876 + \
1.*Bpow(e,2),-4)*((7.222205577492839e-9 - 5.368447958560419e-9*eta + \
7.623310003722372e-9*y)*Bpow(e,56)*Bpow(y,5) - \
5.2391001053208175e-11*Bpow(e,58)*Bpow(y,6) - \
1.5922590606975056e-11*Bpow(e,60)*Bpow(y,6) + \
1.9647027874856209e-13*Bpow(e,62)*Bpow(y,6) + \
9.267606860580853e-14*Bpow(e,64)*Bpow(y,6) + \
2.272724384273139e-14*Bpow(e,66)*Bpow(y,6) + \
1.8164846345041247e-14*Bpow(e,68)*Bpow(y,6) + \
1.3061009028181723e-14*Bpow(e,70)*Bpow(y,6) + \
8.542768385613278e-15*Bpow(e,72)*Bpow(y,6) + \
5.471786696522864e-15*Bpow(e,74)*Bpow(y,6) + \
3.508322729276631e-15*Bpow(e,76)*Bpow(y,6) + \
2.261713193886654e-15*Bpow(e,78)*Bpow(y,6) + \
1.4654636243136919e-15*Bpow(e,80)*Bpow(y,6) + \
9.524697789373047e-16*Bpow(e,82)*Bpow(y,6) + \
6.191860071466212e-16*Bpow(e,84)*Bpow(y,6) + \
4.0110036148727564e-16*Bpow(e,86)*Bpow(y,6) + \
2.5760831465249486e-16*Bpow(e,88)*Bpow(y,6) + \
1.62862763656313e-16*Bpow(e,90)*Bpow(y,6) + \
1.0022747659501622e-16*Bpow(e,92)*Bpow(y,6) + \
5.888386545889803e-17*Bpow(e,94)*Bpow(y,6) + \
3.173082209742216e-17*Bpow(e,96)*Bpow(y,6) + \
1.406888878102617e-17*Bpow(e,98)*Bpow(y,6) + \
2.7659111240045e-18*Bpow(e,100)*Bpow(y,6) + \
Bpow(e,54)*(-5.855608800953821e-10*Bpow(y,3) + (8.329743694552305e-8 \
- 5.864688615885253e-8*eta)*Bpow(y,5) + 3.934157622732405*Bpow(y,6)) \
+ Bpow(e,52)*(-3.6959782013743024e-9*Bpow(y,3) + \
(2.8077035629917353e-7 - 1.8663054532581317e-7*eta)*Bpow(y,5) + \
25.177795618376123*Bpow(y,6)) + \
Bpow(e,50)*(-8.463428179793788e-9*Bpow(y,3) + (4.484612829068095e-7 - \
2.7872533796194856e-7*eta)*Bpow(y,5) + 58.16151538302442*Bpow(y,6)) + \
Bpow(e,48)*(-1.0972922735973442e-8*Bpow(y,3) + (5.934564443254375e-7 \
- 3.628059292920844e-7*eta)*Bpow(y,5) + 71.54925762827655*Bpow(y,6)) \
+ Bpow(e,46)*(-1.4387185443399233e-8*Bpow(y,3) + \
(7.949664243262897e-7 - 4.776611133253385e-7*eta)*Bpow(y,5) + \
78.08945091298402*Bpow(y,6)) + \
Bpow(e,44)*(-1.9094521289602364e-8*Bpow(y,3) + (1.079116883412383e-6 \
- 6.366468893851195e-7*eta)*Bpow(y,5) + 80.97154255259608*Bpow(y,6)) \
+ Bpow(e,42)*(-2.567807683082241e-8*Bpow(y,3) + \
(1.4861592904787735e-6 - 8.598474129985774e-7*eta)*Bpow(y,5) + \
83.57667618941683*Bpow(y,6)) + \
Bpow(e,40)*(-3.502812174448622e-8*Bpow(y,3) + (2.079284635395159e-6 - \
1.177912887256911e-6*eta)*Bpow(y,5) + 88.60412141040261*Bpow(y,6)) + \
Bpow(e,38)*(-4.8526995690565914e-8*Bpow(y,3) + (2.9596826837659446e-6 \
- 1.6382810863427674e-6*eta)*Bpow(y,5) + 94.08004985542546*Bpow(y,6)) \
+ Bpow(e,36)*(-6.835756200007866e-8*Bpow(y,3) + \
(4.2927458528435325e-6 - 2.315253678849214e-6*eta)*Bpow(y,5) + \
100.34797796914312*Bpow(y,6)) + \
Bpow(e,34)*(-9.802096724801076e-8*Bpow(y,3) + (6.35431777121156e-6 - \
3.325990695391769e-6*eta)*Bpow(y,5) + 107.4093051846022*Bpow(y,6)) + \
Bpow(e,32)*(-1.4319843071273382e-7*Bpow(y,3) + (9.612482712114379e-6 \
- 4.854100390362579e-6*eta)*Bpow(y,5) + 115.56518810522314*Bpow(y,6)) \
+ Bpow(e,30)*(-2.131114681686435e-7*Bpow(y,3) + \
(0.000014866920552685691 - 7.1749163866917435e-6*eta)*Bpow(y,5) + \
125.07225325007934*Bpow(y,6)) + \
Bpow(e,28)*(-3.2217817839114584e-7*Bpow(y,3) + \
(0.000023446079275300648 - 0.000010621271076719894*eta)*Bpow(y,5) + \
136.29899626523454*Bpow(y,6)) + \
Bpow(e,26)*(-4.886096454568523e-7*Bpow(y,3) + (0.00003728294163869791 \
- 0.000015070937439541271*eta)*Bpow(y,5) + \
149.7598688639447*Bpow(y,6)) + \
Bpow(e,24)*(-7.062989120173988e-7*Bpow(y,3) + \
(0.000058652839679460484 - 0.00001697924565987077*eta)*Bpow(y,5) + \
166.20466733079496*Bpow(y,6)) + \
Bpow(e,22)*(-7.909606025295725e-7*Bpow(y,3) + (0.00010185396271924219 \
- 5.526718577190668e-6*eta)*Bpow(y,5) + 186.76635973560812*Bpow(y,6)) \
+ Bpow(e,20)*(-3.8897840380463816e-7*Bpow(y,3) + \
(0.00033491992259266414 - 0.00006351089344169582*eta)*Bpow(y,5) + \
213.249041622337*Bpow(y,6)) + \
Bpow(e,18)*(-6.6204616142441025e-6*Bpow(y,3) + (0.0006954104958053227 \
- 0.0004503794606781715*eta)*Bpow(y,5) + \
248.73119597739685*Bpow(y,6)) + \
Bpow(e,16)*(-0.00002508176021958391*Bpow(y,3) + \
(-0.026461879759433548 + 0.014851694930122256*eta)*Bpow(y,5) + \
298.97624297158325*Bpow(y,6)) + \
Bpow(e,14)*(0.0016918241576264115*Bpow(y,3) + (-0.12001708727381051 + \
0.1287096013736833*eta)*Bpow(y,5) + (368.53841478328775 + \
22.888774528939148*eta - 13.589334225277467*Bpow(eta,2) + \
1.5347501104761605*Bpow(eta,3))*Bpow(y,6)) + \
Bpow(y,6)*(-2.9980521483280085 + 2.9980521483280085*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(e,12)*Bpow(y,3)*(0.0076790905535633934 + \
y*(2.790262939221341 - 4.80087824281201*eta + \
1.2030642279134993*Bpow(eta,2)) + (4.698932695631432 - \
2.2284427146954715*eta)*Bpow(y,2) + Bpow(y,3)*(426.226968708107 + \
15.658289703269471*Bpow(eta,3) + eta*(252.02307259047 - \
11.573715164600202*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
9.297576982551385*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(-148.4120123812924 + 2.577465579790931*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,10)*Bpow(y,2)*(-0.7644933015894699 + \
0.5682671948637389*eta - 0.8056340007151568*y + (52.56012260231033 - \
15.19030381887852*eta)*Bpow(y,3) + Bpow(y,2)*(32.51653843660055 + \
14.155994493956458*Bpow(eta,2) + eta*(-55.828590085459496 + \
0.5788539034218975*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
1.4471347585547443*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,4)*(354.71786096735923 + 38.39263831664789*Bpow(eta,3) + \
eta*(1083.8173000949218 - 123.00242321887127*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 107.72345628459064*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(-649.7733917607203 + 25.234927705188042*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,2)*(1.9659412198555002 + \
(2.6024701204572107 + 8.803622743300288*eta)*Bpow(y,2) - \
40.02331379132951*Bpow(y,3) + (-25.14678049359871 - \
63.31319287764015*eta)*Bpow(y,5) + Bpow(y,4)*(52.32658129424142 + \
24.833887179447746*Bpow(eta,2) - 43.19897154156166*Bpow(1. - \
1.*Bpow(e,2),0.5) + eta*(-17.828400907594915 + \
17.279588616624658*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(y,6)*(81.77943692015579 + 58.051300225984285*Bpow(eta,3) + \
27.90373890605939*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(-90.78175915917113 + 37.638334937939945*Bpow(1. - \
1.*Bpow(e,2),0.5)) + eta*(240.68087207343726 + \
181.92636314948055*Bpow(1. - 1.*Bpow(e,2),0.5)))) + \
Bpow(e,8)*(0.12396694214876035 + (-8.22007378964492 + \
6.826977733196881*eta)*Bpow(y,2) - 13.691269151686921*Bpow(y,3) + \
(404.6744388722484 - 201.8690822421167*eta)*Bpow(y,5) + \
Bpow(y,4)*(173.19089183769455 + 88.58156035434645*Bpow(eta,2) - \
25.105888253353964*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-282.595020546158 + 10.042355301341587*Bpow(1. - \
1.*Bpow(e,2),0.5))) + Bpow(y,6)*(-690.9274551247036 + \
549.9022286373303*Bpow(eta,3) + eta*(4026.133691916808 - \
879.8527528008132*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
828.5979478976573*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(-2889.3275040492535 + 232.75016644866713*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,6)*(0.9343624069394172 + \
(-26.415116529341677 + 24.93792463863441*eta)*Bpow(y,2) - \
59.73381339923718*Bpow(y,3) + (800.8328656828957 - \
485.41646296216686*eta)*Bpow(y,5) + Bpow(y,4)*(300.4543071394882 + \
177.13644962844657*Bpow(eta,2) - 105.59215692117746*Bpow(1. - \
1.*Bpow(e,2),0.5) + eta*(-458.79316519897293 + \
42.23686276847098*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(y,6)*(1087.4855866110518 + 82.29328674151017*Bpow(eta,3) + \
eta*(-337.61336749570364 - 1384.4449687764434*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 1497.9477296879747*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(77.14380783811065 + 491.14485487540895*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,4)*(2.3474890223932467 + \
(-25.5669544597568 + 32.077131061343806*eta)*Bpow(y,2) - \
92.49496884181505*Bpow(y,3) + (88.68050100260564 - \
113.66073580834649*eta)*Bpow(y,5) + Bpow(y,4)*(86.97697829162367 + \
72.34298273215315*Bpow(eta,2) - 146.96142400556758*Bpow(1. - \
1.*Bpow(e,2),0.5) + eta*(-70.06918359762953 + \
58.784569602227045*Bpow(1. - 1.*Bpow(e,2),0.5))) + \
Bpow(y,6)*(500.6693698823971 + 127.96615292401498*Bpow(eta,3) - \
118.25517228833824*Bpow(1. - 1.*Bpow(e,2),0.5) + \
Bpow(eta,2)*(-134.2543952949723 + 77.27706546480836*Bpow(1. - \
1.*Bpow(e,2),0.5)) + eta*(119.30537670643572 + \
658.3748625400842*Bpow(1. - 1.*Bpow(e,2),0.5)))) + \
Bpow(e,2)*(-81.08448190143865 - 357.88565388420477*Bpow(e,2) - \
387.66313719867367*Bpow(e,4) - 164.62226900423389*Bpow(e,6) - \
26.895183400402253*Bpow(e,8) - \
0.8973479563261684*Bpow(e,10))*Bpow(y,6)*log(Bpow(y,-1)*(0.125*Bpow(1.\
 - 1.*Bpow(e,2),-1.5) + 0.125*Bpow(1. - 1.*Bpow(e,2),-1))));
}
double TaylorT4::dlde_6(double y, double e)
{
return Bpow(e,-3)*Bpow(eta,-1)*Bpow(y,-5)*Bpow(2.512396694214876 + \
1.*Bpow(e,2),-4)*((-7.2222055774928385e-9 + 5.368447958560419e-9*eta \
- 7.623310003722368e-9*y)*Bpow(e,56)*Bpow(y,5) + \
Bpow(e,16)*(0.00002508176021958391*Bpow(y,3) + (0.026386634478774793 \
- 0.01485169493012225*eta)*Bpow(y,5) - 298.97624297158336*Bpow(y,6)) \
+ Bpow(e,18)*(6.620461614244102e-6*Bpow(y,3) + (-0.000715271880648055 \
+ 0.0004503794606781716*eta)*Bpow(y,5) - \
248.73119597739696*Bpow(y,6)) + \
Bpow(e,20)*(3.8897840380463806e-7*Bpow(y,3) + (-0.000336086857804078 \
+ 0.00006351089344169585*eta)*Bpow(y,5) - \
213.24904162233707*Bpow(y,6)) + \
Bpow(e,22)*(7.909606025295725e-7*Bpow(y,3) + (-0.0001042268445268309 \
+ 5.526718577190668e-6*eta)*Bpow(y,5) - 186.76635973560812*Bpow(y,6)) \
+ Bpow(e,24)*(7.062989120173989e-7*Bpow(y,3) + \
(-0.00006077173641551269 + 0.000016979245659870767*eta)*Bpow(y,5) - \
166.20466733079496*Bpow(y,6)) + \
Bpow(e,26)*(4.886096454568522e-7*Bpow(y,3) + \
(-0.000038748770575068464 + 0.000015070937439541271*eta)*Bpow(y,5) - \
149.75986886394475*Bpow(y,6)) + \
Bpow(e,28)*(3.2217817839114584e-7*Bpow(y,3) + \
(-0.000024412613810474083 + 0.000010621271076719894*eta)*Bpow(y,5) - \
136.2989962652345*Bpow(y,6)) + \
Bpow(e,30)*(2.131114681686434e-7*Bpow(y,3) + (-0.00001550625495719162 \
+ 7.1749163866917435e-6*eta)*Bpow(y,5) - \
125.07225325007937*Bpow(y,6)) + \
Bpow(e,32)*(1.4319843071273376e-7*Bpow(y,3) + \
(-0.000010042078004252578 + 4.854100390362577e-6*eta)*Bpow(y,5) - \
115.56518810522314*Bpow(y,6)) + \
Bpow(e,34)*(9.802096724801073e-8*Bpow(y,3) + (-6.64838067295559e-6 + \
3.3259906953917682e-6*eta)*Bpow(y,5) - 107.40930518460223*Bpow(y,6)) \
+ Bpow(e,36)*(6.835756200007866e-8*Bpow(y,3) + (-4.497818538843769e-6 \
+ 2.3152536788492145e-6*eta)*Bpow(y,5) - \
100.34797796914316*Bpow(y,6)) + \
Bpow(e,38)*(4.8526995690565914e-8*Bpow(y,3) + (-3.105263670837642e-6 \
+ 1.6382810863427674e-6*eta)*Bpow(y,5) - 94.08004985542547*Bpow(y,6)) \
+ Bpow(e,40)*(3.502812174448622e-8*Bpow(y,3) + \
(-2.1843690006286187e-6 + 1.1779128872569106e-6*eta)*Bpow(y,5) - \
88.6041214104026*Bpow(y,6)) + \
Bpow(e,42)*(2.5678076830822405e-8*Bpow(y,3) + (-1.5631935209712411e-6 \
+ 8.598474129985772e-7*eta)*Bpow(y,5) - 83.57667618941684*Bpow(y,6)) \
+ Bpow(e,44)*(1.909452128960237e-8*Bpow(y,3) + (-1.13640044728119e-6 \
+ 6.366468893851193e-7*eta)*Bpow(y,5) - 80.97154255259606*Bpow(y,6)) \
+ Bpow(e,46)*(1.4387185443399228e-8*Bpow(y,3) + \
(-8.381279806564871e-7 + 4.776611133253385e-7*eta)*Bpow(y,5) - \
78.08945091298403*Bpow(y,6)) + \
Bpow(e,48)*(1.0972922735973442e-8*Bpow(y,3) + (-6.263752125333579e-7 \
+ 3.628059292920844e-7*eta)*Bpow(y,5) - 71.54925762827656*Bpow(y,6)) \
+ Bpow(e,50)*(8.46342817979379e-9*Bpow(y,3) + (-4.7385156744619106e-7 \
+ 2.787253379619485e-7*eta)*Bpow(y,5) - 58.16151538302445*Bpow(y,6)) \
+ Bpow(e,52)*(3.695978201374301e-9*Bpow(y,3) + (-2.918582909032966e-7 \
+ 1.8663054532581314e-7*eta)*Bpow(y,5) - \
25.177795618376123*Bpow(y,6)) + \
Bpow(e,54)*(5.855608800953822e-10*Bpow(y,3) + (-8.505411958580923e-8 \
+ 5.864688615885252e-8*eta)*Bpow(y,5) - 3.9341576227324033*Bpow(y,6)) \
+ 5.239100105320818e-11*Bpow(e,58)*Bpow(y,6) + \
1.5922590606975056e-11*Bpow(e,60)*Bpow(y,6) - \
1.9647027874856214e-13*Bpow(e,62)*Bpow(y,6) - \
9.267606860580854e-14*Bpow(e,64)*Bpow(y,6) - \
2.272724384273139e-14*Bpow(e,66)*Bpow(y,6) - \
1.816484634504125e-14*Bpow(e,68)*Bpow(y,6) - \
1.3061009028181729e-14*Bpow(e,70)*Bpow(y,6) - \
8.542768385613273e-15*Bpow(e,72)*Bpow(y,6) - \
5.471786696522862e-15*Bpow(e,74)*Bpow(y,6) - \
3.50832272927663e-15*Bpow(e,76)*Bpow(y,6) - \
2.2617131938866534e-15*Bpow(e,78)*Bpow(y,6) - \
1.4654636243136915e-15*Bpow(e,80)*Bpow(y,6) - \
9.524697789373047e-16*Bpow(e,82)*Bpow(y,6) - \
6.191860071466211e-16*Bpow(e,84)*Bpow(y,6) - \
4.0110036148727564e-16*Bpow(e,86)*Bpow(y,6) - \
2.576083146524948e-16*Bpow(e,88)*Bpow(y,6) - \
1.62862763656313e-16*Bpow(e,90)*Bpow(y,6) - \
1.002274765950162e-16*Bpow(e,92)*Bpow(y,6) - \
5.888386545889807e-17*Bpow(e,94)*Bpow(y,6) - \
3.173082209742217e-17*Bpow(e,96)*Bpow(y,6) - \
1.406888878102617e-17*Bpow(e,98)*Bpow(y,6) - \
2.7659111240045005e-18*Bpow(e,100)*Bpow(y,6) + \
Bpow(e,14)*(-0.0016918241576264115*Bpow(y,3) + (0.12509255974668973 - \
0.12870960137368329*eta)*Bpow(y,5) + (-368.53841478328786 - \
22.88877452893915*eta + 13.589334225277462*Bpow(eta,2) - \
1.5347501104761623*Bpow(eta,3))*Bpow(y,6)) + \
Bpow(y,6)*(2.9980521483280094 - 2.9980521483280094*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(e,2)*(-1.9659412198555004 + \
(3.29535353910929 - 8.803622743300288*eta)*Bpow(y,2) + \
40.0233137913295*Bpow(y,3) + (-94.92316088038984 + \
63.31319287764014*eta)*Bpow(y,5) + Bpow(y,6)*(83.96251067484229 - \
58.051300225984306*Bpow(eta,3) + eta*(-422.7953276555756 - \
141.88324461873944*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(eta,2)*(117.41965003340098 - 37.63833493793993*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 128.0115352329118*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,4)*(-35.672435443520015 - 24.83388717944776*Bpow(eta,2) + \
eta*(30.477680598507277 - 17.279588616624665*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 43.19897154156165*Bpow(1. - 1.*Bpow(e,2),0.5))) \
+ Bpow(e,4)*(-2.347489022393246 + (32.609421526936536 - \
32.077131061343806*eta)*Bpow(y,2) + 92.49496884181505*Bpow(y,3) + \
(-366.1654075280508 + 113.66073580834647*eta)*Bpow(y,5) + \
Bpow(y,6)*(-193.9028931488378 - 127.96615292401475*Bpow(eta,3) + \
eta*(-345.6162844625427 - 519.6973825060285*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(eta,2)*(164.58995018154613 - \
77.2770654648082*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
228.43852779680046*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,4)*(-128.04839051696686 - 72.34298273215313*Bpow(eta,2) + \
eta*(137.08953569584756 - 58.78456960222702*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 146.96142400556758*Bpow(1. - 1.*Bpow(e,2),0.5))) \
+ Bpow(e,12)*Bpow(y,3)*(-0.007679090553563395 + y*(-2.790262939221341 \
+ 4.80087824281201*eta - 1.2030642279134995*Bpow(eta,2)) + \
(-4.675895423970742 + 2.228442714695472*eta)*Bpow(y,2) + \
Bpow(y,3)*(-425.186114113807 - 15.658289703269475*Bpow(eta,3) + \
Bpow(eta,2)*(149.3346997033769 - 2.577465579790931*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 9.297576982551385*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-255.9156395786075 + 11.5737151646002*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,10)*Bpow(y,2)*(0.7644933015894699 - \
0.5682671948637388*eta + 0.8056340007151567*y + (-54.977024604455785 \
+ 15.190303818878512*eta)*Bpow(y,3) + Bpow(y,2)*(-33.229439828972254 \
- 14.155994493956456*Bpow(eta,2) + eta*(56.72760654608374 - \
0.5788539034218975*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
1.4471347585547438*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,4)*(-338.9195460089313 - 38.39263831664812*Bpow(eta,3) + \
Bpow(eta,2)*(656.4385218550977 - 25.234927705188024*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 108.34585229579204*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-1131.8851291311626 + 123.2513816233519*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,8)*(-0.12396694214876033 + \
(8.5919746160912 - 6.82697773319688*eta)*Bpow(y,2) + \
13.691269151686917*Bpow(y,3) + (-445.7482463273092 + \
201.86908224211678*eta)*Bpow(y,5) + Bpow(y,4)*(-185.38014127848234 - \
88.58156035434644*Bpow(eta,2) + eta*(296.13482950560115 - \
10.042355301341587*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
25.105888253353964*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,6)*(944.6758390219302 - 549.9022286373302*Bpow(eta,3) + \
Bpow(eta,2)*(3002.5024440083585 - 232.75016644866704*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 874.0252363173053*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-4459.2203862497445 + 898.0236681686727*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,6)*(-0.9343624069394169 + \
(29.218203750159923 - 24.937924638634403*eta)*Bpow(y,2) + \
59.733813399237185*Bpow(y,3) + (-980.0343058806072 + \
485.4164629621669*eta)*Bpow(y,5) + Bpow(y,4)*(-345.5645408607722 - \
177.13644962844654*Bpow(eta,2) + eta*(511.80772362074435 - \
42.23686276847098*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
105.59215692117746*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,6)*(-437.3401565150054 - 82.29328674150929*Bpow(eta,3) + \
Bpow(eta,2)*(187.61208683368807 - 491.14485487540884*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 1730.2840936756188*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-570.0183396593015 + 1477.3795143715013*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,2)*(81.08448190143866 + \
357.88565388420477*Bpow(e,2) + 387.6631371986736*Bpow(e,4) + \
164.62226900423394*Bpow(e,6) + 26.895183400402242*Bpow(e,8) + \
0.8973479563261683*Bpow(e,10))*Bpow(y,6)*log(Bpow(y,-1)*(0.125*Bpow(1.\
 - 1.*Bpow(e,2),-1.5) + 0.125*Bpow(1. - 1.*Bpow(e,2),-1))));
}
double TaylorT4::dlamde_6(double y, double e)
{
return Bpow(e,-3)*Bpow(eta,-1)*Bpow(y,-5)*Bpow(2.512396694214876 + \
1.*Bpow(e,2),-4)*((-7.222205577492837e-9 + 5.368447958560419e-9*eta - \
7.623310003722368e-9*y)*Bpow(e,56)*Bpow(y,5) + \
Bpow(e,16)*(0.00002508176021958391*Bpow(y,3) + (0.026461879759433555 \
- 0.014851694930122252*eta)*Bpow(y,5) - 298.97624297158336*Bpow(y,6)) \
+ Bpow(e,18)*(6.620461614244102e-6*Bpow(y,3) + \
(-0.0006954104958053227 + 0.0004503794606781716*eta)*Bpow(y,5) - \
248.73119597739696*Bpow(y,6)) + \
Bpow(e,20)*(3.8897840380463806e-7*Bpow(y,3) + \
(-0.00033491992259266414 + 0.00006351089344169585*eta)*Bpow(y,5) - \
213.24904162233707*Bpow(y,6)) + \
Bpow(e,22)*(7.909606025295725e-7*Bpow(y,3) + (-0.00010185396271924218 \
+ 5.526718577190668e-6*eta)*Bpow(y,5) - 186.76635973560812*Bpow(y,6)) \
+ Bpow(e,24)*(7.062989120173989e-7*Bpow(y,3) + \
(-0.0000586528396794605 + 0.000016979245659870767*eta)*Bpow(y,5) - \
166.20466733079496*Bpow(y,6)) + \
Bpow(e,26)*(4.886096454568522e-7*Bpow(y,3) + (-0.00003728294163869792 \
+ 0.000015070937439541271*eta)*Bpow(y,5) - \
149.75986886394475*Bpow(y,6)) + \
Bpow(e,28)*(3.2217817839114584e-7*Bpow(y,3) + \
(-0.00002344607927530065 + 0.000010621271076719894*eta)*Bpow(y,5) - \
136.2989962652345*Bpow(y,6)) + \
Bpow(e,30)*(2.131114681686434e-7*Bpow(y,3) + \
(-0.000014866920552685691 + 7.1749163866917435e-6*eta)*Bpow(y,5) - \
125.07225325007937*Bpow(y,6)) + \
Bpow(e,32)*(1.4319843071273376e-7*Bpow(y,3) + (-9.612482712114377e-6 \
+ 4.854100390362577e-6*eta)*Bpow(y,5) - 115.56518810522314*Bpow(y,6)) \
+ Bpow(e,34)*(9.802096724801073e-8*Bpow(y,3) + (-6.354317771211558e-6 \
+ 3.325990695391769e-6*eta)*Bpow(y,5) - 107.40930518460223*Bpow(y,6)) \
+ Bpow(e,36)*(6.835756200007866e-8*Bpow(y,3) + \
(-4.2927458528435325e-6 + 2.315253678849215e-6*eta)*Bpow(y,5) - \
100.34797796914316*Bpow(y,6)) + \
Bpow(e,38)*(4.8526995690565914e-8*Bpow(y,3) + (-2.959682683765944e-6 \
+ 1.6382810863427674e-6*eta)*Bpow(y,5) - 94.08004985542547*Bpow(y,6)) \
+ Bpow(e,40)*(3.502812174448622e-8*Bpow(y,3) + (-2.07928463539516e-6 \
+ 1.1779128872569106e-6*eta)*Bpow(y,5) - 88.6041214104026*Bpow(y,6)) \
+ Bpow(e,42)*(2.567807683082241e-8*Bpow(y,3) + \
(-1.4861592904787735e-6 + 8.598474129985772e-7*eta)*Bpow(y,5) - \
83.57667618941684*Bpow(y,6)) + \
Bpow(e,44)*(1.909452128960237e-8*Bpow(y,3) + (-1.079116883412383e-6 + \
6.366468893851195e-7*eta)*Bpow(y,5) - 80.97154255259606*Bpow(y,6)) + \
Bpow(e,46)*(1.4387185443399228e-8*Bpow(y,3) + (-7.949664243262895e-7 \
+ 4.776611133253385e-7*eta)*Bpow(y,5) - 78.08945091298403*Bpow(y,6)) \
+ Bpow(e,48)*(1.0972922735973442e-8*Bpow(y,3) + \
(-5.934564443254376e-7 + 3.628059292920844e-7*eta)*Bpow(y,5) - \
71.54925762827656*Bpow(y,6)) + \
Bpow(e,50)*(8.46342817979379e-9*Bpow(y,3) + (-4.4846128290680957e-7 + \
2.787253379619485e-7*eta)*Bpow(y,5) - 58.16151538302445*Bpow(y,6)) + \
Bpow(e,52)*(3.695978201374301e-9*Bpow(y,3) + (-2.807703562991736e-7 + \
1.8663054532581314e-7*eta)*Bpow(y,5) - 25.177795618376123*Bpow(y,6)) \
+ Bpow(e,54)*(5.855608800953822e-10*Bpow(y,3) + \
(-8.329743694552307e-8 + 5.864688615885252e-8*eta)*Bpow(y,5) - \
3.9341576227324033*Bpow(y,6)) + \
5.239100105320818e-11*Bpow(e,58)*Bpow(y,6) + \
1.5922590606975056e-11*Bpow(e,60)*Bpow(y,6) - \
1.9647027874856214e-13*Bpow(e,62)*Bpow(y,6) - \
9.267606860580854e-14*Bpow(e,64)*Bpow(y,6) - \
2.272724384273139e-14*Bpow(e,66)*Bpow(y,6) - \
1.816484634504125e-14*Bpow(e,68)*Bpow(y,6) - \
1.3061009028181729e-14*Bpow(e,70)*Bpow(y,6) - \
8.542768385613273e-15*Bpow(e,72)*Bpow(y,6) - \
5.471786696522862e-15*Bpow(e,74)*Bpow(y,6) - \
3.50832272927663e-15*Bpow(e,76)*Bpow(y,6) - \
2.2617131938866534e-15*Bpow(e,78)*Bpow(y,6) - \
1.4654636243136915e-15*Bpow(e,80)*Bpow(y,6) - \
9.524697789373047e-16*Bpow(e,82)*Bpow(y,6) - \
6.191860071466211e-16*Bpow(e,84)*Bpow(y,6) - \
4.0110036148727564e-16*Bpow(e,86)*Bpow(y,6) - \
2.576083146524948e-16*Bpow(e,88)*Bpow(y,6) - \
1.62862763656313e-16*Bpow(e,90)*Bpow(y,6) - \
1.002274765950162e-16*Bpow(e,92)*Bpow(y,6) - \
5.888386545889807e-17*Bpow(e,94)*Bpow(y,6) - \
3.173082209742217e-17*Bpow(e,96)*Bpow(y,6) - \
1.406888878102617e-17*Bpow(e,98)*Bpow(y,6) - \
2.7659111240045005e-18*Bpow(e,100)*Bpow(y,6) + \
Bpow(e,14)*(-0.0016918241576264115*Bpow(y,3) + (0.1200170872738105 - \
0.12870960137368329*eta)*Bpow(y,5) + (-368.53841478328786 - \
22.88877452893915*eta + 13.589334225277462*Bpow(eta,2) - \
1.5347501104761623*Bpow(eta,3))*Bpow(y,6)) + \
Bpow(y,6)*(2.9980521483280094 - 2.9980521483280094*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(e,2)*(-1.9659412198555004 + \
(-2.6024701204572107 - 8.803622743300288*eta)*Bpow(y,2) + \
40.0233137913295*Bpow(y,3) + (25.146780493598715 + \
63.313192877640134*eta)*Bpow(y,5) + Bpow(y,6)*(-81.77943692015626 - \
58.051300225984306*Bpow(eta,3) + eta*(-240.68087207343723 - \
181.92636314948047*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(eta,2)*(90.78175915917117 - 37.63833493793993*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 27.903738906059367*Bpow(1. - 1.*Bpow(e,2),0.5)) \
+ Bpow(y,4)*(-52.3265812942414 - 24.83388717944775*Bpow(eta,2) + \
eta*(17.828400907594915 - 17.279588616624665*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 43.19897154156165*Bpow(1. - 1.*Bpow(e,2),0.5))) \
+ Bpow(e,4)*(-2.3474890223932454 + (25.5669544597568 - \
32.077131061343806*eta)*Bpow(y,2) + 92.49496884181505*Bpow(y,3) + \
(-88.68050100260564 + 113.6607358083465*eta)*Bpow(y,5) + \
Bpow(y,6)*(-500.6693698823974 - 127.96615292401475*Bpow(eta,3) + \
eta*(-119.30537670643525 - 658.3748625400848*Bpow(1. - \
1.*Bpow(e,2),0.5)) + Bpow(eta,2)*(134.25439529497237 - \
77.2770654648082*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
118.25517228833851*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,4)*(-86.9769782916237 - 72.34298273215312*Bpow(eta,2) + \
eta*(70.06918359762955 - 58.784569602227045*Bpow(1. - \
1.*Bpow(e,2),0.5)) + 146.96142400556758*Bpow(1. - 1.*Bpow(e,2),0.5))) \
+ Bpow(e,12)*Bpow(y,3)*(-0.007679090553563395 + \
y*(-2.7902629392213414 + 4.80087824281201*eta - \
1.2030642279134993*Bpow(eta,2)) + (-4.698932695631432 + \
2.228442714695471*eta)*Bpow(y,2) + Bpow(y,3)*(-426.22696870810677 - \
15.658289703269475*Bpow(eta,3) + Bpow(eta,2)*(148.41201238129213 - \
2.577465579790931*Bpow(1. - 1.*Bpow(e,2),0.5)) - \
9.297576982551385*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-252.02307259047006 + 11.5737151646002*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,10)*Bpow(y,2)*(0.7644933015894699 - \
0.5682671948637388*eta + 0.8056340007151567*y + (-52.560122602310315 \
+ 15.190303818878514*eta)*Bpow(y,3) + Bpow(y,2)*(-32.516538436600534 \
- 14.155994493956458*Bpow(eta,2) + eta*(55.82859008545948 - \
0.5788539034218975*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
1.4471347585547438*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,4)*(-354.71786096735923 - 38.39263831664812*Bpow(eta,3) + \
Bpow(eta,2)*(649.7733917607202 - 25.23492770518801*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 107.72345628459061*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-1083.8173000949237 + 123.00242321887134*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,8)*(-0.12396694214876033 + \
(8.22007378964492 - 6.82697773319688*eta)*Bpow(y,2) + \
13.691269151686917*Bpow(y,3) + (-404.67443887224846 + \
201.86908224211672*eta)*Bpow(y,5) + Bpow(y,4)*(-173.19089183769455 - \
88.58156035434648*Bpow(eta,2) + eta*(282.595020546158 - \
10.042355301341587*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
25.105888253353964*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,6)*(690.9274551247026 - 549.9022286373302*Bpow(eta,3) + \
Bpow(eta,2)*(2889.3275040492554 - 232.75016644866702*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 828.5979478976573*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(-4026.1336919168116 + 879.8527528008136*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,6)*(-0.9343624069394167 + \
(26.415116529341674 - 24.937924638634403*eta)*Bpow(y,2) + \
59.733813399237185*Bpow(y,3) + (-800.8328656828957 + \
485.41646296216675*eta)*Bpow(y,5) + Bpow(y,4)*(-300.4543071394883 - \
177.13644962844663*Bpow(eta,2) + eta*(458.7931651989731 - \
42.236862768470985*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
105.59215692117746*Bpow(1. - 1.*Bpow(e,2),0.5)) + \
Bpow(y,6)*(-1087.4855866110524 - 82.29328674150929*Bpow(eta,3) + \
Bpow(eta,2)*(-77.14380783810884 - 491.14485487540884*Bpow(1. - \
1.*Bpow(e,2),0.5)) - 1497.9477296879752*Bpow(1. - 1.*Bpow(e,2),0.5) + \
eta*(337.61336749570273 + 1384.4449687764438*Bpow(1. - \
1.*Bpow(e,2),0.5)))) + Bpow(e,2)*(81.08448190143866 + \
357.88565388420477*Bpow(e,2) + 387.6631371986736*Bpow(e,4) + \
164.62226900423394*Bpow(e,6) + 26.895183400402246*Bpow(e,8) + \
0.8973479563261682*Bpow(e,10))*Bpow(y,6)*log(Bpow(y,-1)*(0.125*Bpow(1.\
 - 1.*Bpow(e,2),-1.5) + 0.125*Bpow(1. - 1.*Bpow(e,2),-1))));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A newtonian estimate for the time to coalesence (used in guessing size of arrays for the time domain orbital ODE solutions)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

double TaylorT4::t_to_coal(){
	double ser;
	double sig;
	double prefac;

	sig = pow(e0, 12./19.)/(1-e0*e0)*pow(1+121./304.*e0*e0, 870./2299.);
	prefac = 15./304.*M/eta*1/(Bpow(1/p0*(1-e0*e0),4.)*pow(sig,4))*19./48*pow(e0,48./19.);
	ser = 1. + 0.9522965921535785*pow(e0,2) + 0.837878626188783*pow(e0,4) +
		   0.7550648835425176*pow(e0,6) + 0.691148594868824*pow(e0,8) +
		   0.6408051763234638*pow(e0,10) + 0.5998533559021704*pow(e0,12) +
		   0.5657772006418743*pow(e0,14) + 0.536862284108107*pow(e0,16) +
		   0.5119394450871947*pow(e0,18) + 0.49017328207429717*pow(e0,20) +
		   0.47095327658705605*pow(e0,22) + 0.4538211395575675*pow(e0,24) +
		   0.43842585503764964*pow(e0,26) + 0.42449347320148845*pow(e0,28) +
		   0.4118067593448706*pow(e0,30);
	return prefac*ser;
}

///////////////////////////////////////////////////////////////
// ODE right hand sides in the form boost requires for solving
///////////////////////////////////////////////////////////////

void TaylorT4::rhs(const state_type &x,  state_type &dxdt,  const double t)
{
    dxdt[0] = ldot(x[2], x[3]);
    dxdt[1] = lamdot(x[2], x[3]);
    dxdt[2] = ydot(x[2], x[3]);
    dxdt[3] = edot(x[2], x[3]);

}
void TaylorT4::rhs_e_6(const state_type &x,  state_type &dxdt,  const double ep)
{
    dxdt[0] = -dlde_6(x[2], -ep);
    dxdt[1] = -dlamde_6(x[2], -ep);
    dxdt[2] = -dyde_6(x[2], -ep);
    dxdt[3] = -dtde_6(x[2], -ep);

}

////////////////////////////////////////////////////////////////////////////////////
// Stop condition for the ODEs (corresponds to a periastron velocity of 1/3)
////////////////////////////////////////////////////////////////////////////////////

double stop_cond(double y, double e){
	return y - 1./(3.*(1.+e));
}

////////////////////////////////////////////////////////////////////////////////////
// This solves the time domain ODEs for all orbital elements in terms of ODEs with
// "t" as the independent variable (some comments for clarity have been added inline)
// time is dimensionless i.e. t -> t'/M
////////////////////////////////////////////////////////////////////////////////////

//void TaylorT4::solorb(){
//	cout << "Solving ODEs for e0 = " << e0 << "and p0 = " << p0 << endl;
//	double t_end = t_to_coal()/M;										// The time to coalesence from newtonian guess
//	double dt = (double) 1./(sr*M);										// The dt given by the sampling rate (in Hz) desired
//	double t = 0;
//	int N = (int) t_end/dt + t_end/dt*0.5;								// Make the arrays a bit large for bad guesses to not run into mem issues
//	int i = 0;
//	tsol.clear();
//	lsol.clear();
//	lamsol.clear();
//	ysol.clear();
//	esol.clear();
//	tsol.resize(N);
//	lsol.resize(N);
//	lamsol.resize(N);
//	ysol.resize(N);
//	esol.resize(N);
//
//	//////////////////////////////////////////////////////
//	// Below is a routine to solve the ODEs using Boost's ODE solvers
//	// If confused, see Boost ODEINT documentation
//	//////////////////////////////////////////////////////
//
//	bulirsch_stoer_dense_out< state_type > stepper( 1E-15 , 1E-15 , 1.0, 1.0 ); //Set error tolerances
//	state_type x = {{ 0, 0, 1./pow( p0, 1./2.), e0 }};  //Initial conditions
//	stepper.initialize( x , t , dt );
//	tsol[0] = t*M;
//	lsol[0] = x[0];
//	lamsol[0] = x[1];
//	ysol[0] = x[2];
//	esol[0] = x[3];
//	t += dt;
//	i++;
//	auto mystate = bind(&TaylorT4::rhs, *this , pl::_1 , pl::_2 , pl::_3);
//    while( t < 2*t_end  )
//    {
//        if( t > stepper.current_time() ) // an actual ode step
//        {
//        	stepper.do_step( mystate );
//        	stepper.calc_state( stepper.current_time() , x );
//        	// Below loop handles nans from the ode stepper overstepping PN validity and hitting nans
//        	if (std::isnan(x[0])){
//        		cout << "nan in ode loop" << endl;
//        		bulirsch_stoer_dense_out< state_type > stepperref( 1E-14 , 1E-14 , 1.0, 1.0 );
//        		stepper = stepperref;
//        		state_type x = {{ lsol[i-2], lamsol[i-2], ysol[i-2], esol[i-2] }};
//        		stepper.initialize( x , t - dt , dt );
//        		stepper.do_step( mystate );
//        		stepper.calc_state( stepper.current_time() , x );
//        	}
//        }
//        else if (i < N) // a dense output step (i.e. interpolated solutions)
//        {
//            stepper.calc_state( t , x );
//         	tsol[i] = t*M;
//        	lsol[i] = x[0];
//        	lamsol[i] = x[1];
//        	ysol[i] = x[2];
//        	esol[i] = x[3];
//            t += dt;
//            i++;
//            if(std::isnan(x[0])){
//                lsol.erase(lsol.begin()+i-1, lsol.begin()+N);
//                lamsol.erase(lamsol.begin()+i-1, lamsol.begin()+N);
//                ysol.erase(ysol.begin()+i-1, ysol.begin()+N);
//                esol.erase(esol.begin()+i-1, esol.begin()+N);
//            	break;
//            }
//        }
//        else if(i >= N){
//            stepper.calc_state( t , x );
//            if(std::isnan(x[0])){
//                lsol.erase(lsol.begin()+i-1, lsol.begin()+N);
//                lamsol.erase(lamsol.begin()+i-1, lamsol.begin()+N);
//                ysol.erase(ysol.begin()+i-1, ysol.begin()+N);
//                esol.erase(esol.begin()+i-1, esol.begin()+N);
//            	break;
//            }
//            tsol.push_back (t*M);
//        	lsol.push_back (x[0]);
//        	lamsol.push_back (x[1]);
//        	ysol.push_back (x[2]);
//        	esol.push_back (x[3]);
//            t += dt;
//            i++;
//        }
//        if( stop_cond(ysol[i-1], esol[i-1]) > 0 ) //Stop condition
//        {
//        	cout << t*M << '\t' << x[0] << '\t' << x[1] << '\t' << x[2] << '\t' << x[3] << endl;
//        	cout << "stop cond = " << stop_cond(ysol[i-1], esol[i-1]) << endl;
//            while(t < stepper.current_time() & stop_cond(ysol[i-1], esol[i-1]) < 0) //Makes sure to get solution leading up to stop condition
//            {
//            	stepper.calc_state( t , x );
//            	if (i <= N){
//            		tsol[i] = t*M;
//            		lsol[i] = x[0];
//            		lamsol[i] = x[1];
//            		ysol[i] = x[2];
//            		esol[i] = x[3];
//            		t += dt;
//            		i++;
//            	} else if (i > N){
//                    tsol.push_back (t*M);
//                	lsol.push_back (x[0]);
//                	lamsol.push_back (x[1]);
//                	ysol.push_back (x[2]);
//                	esol.push_back (x[3]);
//                    t += dt;
//                    i++;
//            	}
//            }
//            if(i < N) //Cleans up the end if the array was too large
//            {
//            	tsol.erase(tsol.begin()+i, tsol.begin()+N);
//            	lsol.erase(lsol.begin()+i, lsol.begin()+N);
//            	lamsol.erase(lamsol.begin()+i, lamsol.begin()+N);
//            	ysol.erase(ysol.begin()+i, ysol.begin()+N);
//            	esol.erase(esol.begin()+i, esol.begin()+N);
//            	cout << "ends snipped" << endl;
//            }
//            break;
//       }
//    }
//}

void TaylorT4::solorb(){
	cout << "Solving ODEs for e0 = " << e0 << "and p0 = " << p0 << endl;
	double t_end = t_to_coal()/M;										// The time to coalesence from newtonian guess
	double dt = (double) t_end/1000000;										// The dt given by the sampling rate (in Hz) desired
	double t = 0;
	int N = (int) t_end/dt + t_end/dt*0.5;								// Make the arrays a bit large for bad guesses to not run into mem issues
	int i = 0;
	tsol.clear();
	lsol.clear();
	lamsol.clear();
	ysol.clear();
	esol.clear();
	tsol.resize(N);
	lsol.resize(N);
	lamsol.resize(N);
	ysol.resize(N);
	esol.resize(N);

	//////////////////////////////////////////////////////
	// Below is a routine to solve the ODEs using Boost's ODE solvers
	// If confused, see Boost ODEINT documentation
	//////////////////////////////////////////////////////

	bulirsch_stoer_dense_out< state_type > stepper( 1E-15 , 1E-15 , 1.0, 1.0 ); //Set error tolerances
	state_type x = {{ 0, 0, 1./pow( p0, 1./2.), e0 }};  //Initial conditions
	stepper.initialize( x , t , dt );
	tsol[0] = t*M;
	lsol[0] = x[0];
	lamsol[0] = x[1];
	ysol[0] = x[2];
	esol[0] = x[3];
	t += dt;
	i++;
	auto mystate = bind(&TaylorT4::rhs, *this , pl::_1 , pl::_2 , pl::_3);
    while( t < 2*t_end  )
    {
        if( t > stepper.current_time() ) // an actual ode step
        {
        	stepper.do_step( mystate );
        	stepper.calc_state( stepper.current_time() , x );
        	// Below loop handles nans from the ode stepper overstepping PN validity and hitting nans
        	if (std::isnan(x[0])){
        		cout << "nan in ode loop" << endl;
        		bulirsch_stoer_dense_out< state_type > stepperref( 1E-14 , 1E-14 , 1.0, 1.0 );
        		stepper = stepperref;
        		state_type x = {{ lsol[i-2], lamsol[i-2], ysol[i-2], esol[i-2] }};
        		stepper.initialize( x , t - dt , dt );
        		stepper.do_step( mystate );
        		stepper.calc_state( stepper.current_time() , x );
        	}
        }
        else if (i < N) // a dense output step (i.e. interpolated solutions)
        {
            stepper.calc_state( t , x );
         	tsol[i] = t*M;
        	lsol[i] = x[0];
        	lamsol[i] = x[1];
        	ysol[i] = x[2];
        	esol[i] = x[3];
            t += dt;
            i++;
            if(std::isnan(x[0])){
                lsol.erase(lsol.begin()+i-1, lsol.begin()+N);
                lamsol.erase(lamsol.begin()+i-1, lamsol.begin()+N);
                ysol.erase(ysol.begin()+i-1, ysol.begin()+N);
                esol.erase(esol.begin()+i-1, esol.begin()+N);
            	break;
            }
        }
        else if(i >= N){
            stepper.calc_state( t , x );
            if(std::isnan(x[0])){
                lsol.erase(lsol.begin()+i-1, lsol.begin()+N);
                lamsol.erase(lamsol.begin()+i-1, lamsol.begin()+N);
                ysol.erase(ysol.begin()+i-1, ysol.begin()+N);
                esol.erase(esol.begin()+i-1, esol.begin()+N);
            	break;
            }
            tsol.push_back (t*M);
        	lsol.push_back (x[0]);
        	lamsol.push_back (x[1]);
        	ysol.push_back (x[2]);
        	esol.push_back (x[3]);
            t += dt;
            i++;
        }
        if( stop_cond(ysol[i-1], esol[i-1]) > 0 ) //Stop condition
        {
        	cout << t*M << '\t' << x[0] << '\t' << x[1] << '\t' << x[2] << '\t' << x[3] << endl;
        	cout << "stop cond = " << stop_cond(ysol[i-1], esol[i-1]) << endl;
            while(t < stepper.current_time() & stop_cond(ysol[i-1], esol[i-1]) < 0) //Makes sure to get solution leading up to stop condition
            {
            	stepper.calc_state( t , x );
            	if (i <= N){
            		tsol[i] = t*M;
            		lsol[i] = x[0];
            		lamsol[i] = x[1];
            		ysol[i] = x[2];
            		esol[i] = x[3];
            		t += dt;
            		i++;
            	} else if (i > N){
                    tsol.push_back (t*M);
                	lsol.push_back (x[0]);
                	lamsol.push_back (x[1]);
                	ysol.push_back (x[2]);
                	esol.push_back (x[3]);
                    t += dt;
                    i++;
            	}
            }
            if(i < N) //Cleans up the end if the array was too large
            {
            	tsol.erase(tsol.begin()+i, tsol.begin()+N);
            	lsol.erase(lsol.begin()+i, lsol.begin()+N);
            	lamsol.erase(lamsol.begin()+i, lamsol.begin()+N);
            	ysol.erase(ysol.begin()+i, ysol.begin()+N);
            	esol.erase(esol.begin()+i, esol.begin()+N);
            	cout << "ends snipped" << endl;
            }
            break;
       }
    }

    cout << "past ODE loop" << endl;

	int size = ysol.size();
	//convert the solutions to things gsl takes
	double *esol_mat, *ysol_mat, *lsol_mat, *tsol_mat, *lamsol_mat;
	esol_mat = (double*)malloc(sizeof(double) * size);
	ysol_mat = (double*)malloc(sizeof(double) * size);
	lsol_mat = (double*)malloc(sizeof(double) * size);
	tsol_mat = (double*)malloc(sizeof(double) * size);
	lamsol_mat = (double*)malloc(sizeof(double) * size);

	//remember that the independent variable has to be increasing or GSL will whine
	for(int i = 0; i < size; i++){
		esol_mat[i] = esol[i];
		ysol_mat[i] = ysol[i];
		lsol_mat[i] = lsol[i];
		tsol_mat[i] = tsol[i];
		lamsol_mat[i] = lamsol[i];
	}

	gsl_spline *spline_y_t = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_e_t = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_l_t = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_lam_t = gsl_spline_alloc (gsl_interp_cspline, size);

	gsl_spline_init (spline_y_t, tsol_mat, ysol_mat, size);
	gsl_spline_init (spline_l_t, tsol_mat, lsol_mat, size);
	gsl_spline_init (spline_lam_t, tsol_mat, lamsol_mat, size);
	gsl_spline_init (spline_e_t, tsol_mat, esol_mat, size);
	free(esol_mat);
	free(tsol_mat);
	free(ysol_mat);
	free(lsol_mat);
	free(lamsol_mat);
	gsl_interp_accel *acc;
	acc = gsl_interp_accel_alloc ();


	double t0 = 0;
	double tend = tsol[size - 1];
	int len =  floor((tend - t0)*sr);
	tsol.clear();
	lsol.clear();
	lamsol.clear();
	ysol.clear();
	esol.clear();
	tsol.resize(len);
	lsol.resize(len);
	lamsol.resize(len);
	ysol.resize(len);
	esol.resize(len);

	for(int i = 0; i < len; i++){
		tsol[i] = (double) 1/sr*i;
		esol[i] = gsl_spline_eval(spline_e_t, tsol[i], acc); //get the eccentricities associated with sampling the signal at sr.
		lsol[i] = gsl_spline_eval(spline_l_t, tsol[i], acc); // use them to evaluate the other functions
		lamsol[i] = gsl_spline_eval(spline_lam_t, tsol[i], acc);
		ysol[i] = gsl_spline_eval(spline_y_t, tsol[i], acc);
	}

	gsl_spline_free(spline_e_t);
	gsl_spline_free(spline_l_t);
	gsl_spline_free(spline_lam_t);
	gsl_spline_free(spline_y_t);
	gsl_interp_accel_free(acc);
	cout << "Orb stuff done" << endl;
}

//Gets the e_{\ast} parameter used in TaylorF2

double TaylorT4::get_eref(){
	double yref = pow(2*M_PI*M*5, 1./3.);
	int size = ysol.size()*0.98;
	//convert the solutions to things gsl takes
	double *esol_mat, *ysol_mat;
	esol_mat = (double*)malloc(sizeof(double) * size);
	ysol_mat = (double*)malloc(sizeof(double) * size);

	for(int i = 0; i < size; i ++){
		esol_mat[i] = esol[i];
		ysol_mat[i] = ysol[i];
	}

	gsl_spline *spline_y_e = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline_init (spline_y_e, ysol_mat, esol_mat, size);
	gsl_interp_accel *acc;
	acc = gsl_interp_accel_alloc ();
	double eref = gsl_spline_eval(spline_y_e, yref, acc);
	free(esol_mat);
	free(ysol_mat);
	gsl_spline_free(spline_y_e);
	gsl_interp_accel_free(acc);

	return eref;
}
void TaylorT4::sol_orb_e_param(){
		sol_orb_e_param_6();
}

////////////////////////////////////////////////////////////////////////
// Solves the ODEs with "e" as the independent variable in the ODES
// then maps e -> t, interpolates,  and obtains the solutions
// in terms of t (i.e. Solve for l(e), y(e), t(e) - > e(t), y(t), l(t))
////////////////////////////////////////////////////////////////////////

void TaylorT4::sol_orb_e_param_6(){
	cout << "Solving ODEs (parameterized in terms of e) for e0 = " << e0 << "and p0 = " << p0 << endl;
	double dep = (double) (e0)/200000;
	int N = (int) 200000;
	int i = 0;
	tsol.clear();
	lsol.clear();
	lamsol.clear();
	ysol.clear();
	esol.clear();
	tsol.resize(N);
	lsol.resize(N);
	lamsol.resize(N);
	ysol.resize(N);
	esol.resize(N);
	double ep = -e0;

	bulirsch_stoer_dense_out< state_type > stepper( 1E-15 , 1E-15 , 1.0, 1.0 );
	state_type x = {{ 0, 0, 1./pow( p0, 1./2.), 0 }};
	stepper.initialize( x , ep , dep );
	esol[0] = -ep;
	lsol[0] = x[0];
	lamsol[0] = x[1];
	ysol[0] = x[2];
	tsol[0] = x[3];
	ep += dep;
	i++;
	auto mystate = bind(&TaylorT4::rhs_e_6, *this , pl::_1 , pl::_2 , pl::_3);
	while( ep < 0  )
	{
        if( ep > stepper.current_time() )
        {
        	stepper.do_step( mystate );
        	stepper.calc_state( stepper.current_time() , x );
        	if (std::isnan(x[0]) || std::isnan(x[1]) || std::isnan(x[2]) || std::isnan(x[3])){
        		cout << "nan in ode loop" << endl;
        		cout << setprecision(8) << -ep << '\t' << x[0] << '\t' << x[1] << '\t' << x[2] << '\t' << x[3] << endl;
        		cout << i << endl;
        		bulirsch_stoer_dense_out< state_type > stepperref( 1E-14 , 1E-14 , 1.0, 1.0 );
        		stepper = stepperref;
        		state_type x = {{ lsol[i-2], lamsol[i-2], ysol[i-2], tsol[i - 2] }};
        		stepper.initialize( x , ep - dep , dep );
        		stepper.do_step( mystate );
        		stepper.calc_state( stepper.current_time() , x );
        	}
        }
        else
        {
            stepper.calc_state( ep , x );
        //    cout << setprecision(8) << -ep << '\t' << x[0] << '\t' << x[1] << '\t' << x[2] << '\t' << x[3] << endl;
         	esol[i] = -ep;
        	lsol[i] = x[0];
        	lamsol[i] = x[1];
        	ysol[i] = x[2];
        	tsol[i] = x[3];
            ep += dep;
            i++;
        }
        if(stop_cond(ysol[i - 1], esol[i - 1]) > 0){
        	cout << "LSO reached" << endl;
        	cout << "Stop condition = " << stop_cond(ysol[i - 1], esol[i - 1]) << endl;
        	cout << setprecision(8) << -ep << '\t' << x[0] << '\t' << x[1] << '\t' << x[2] << '\t' << x[3] << endl;
        	tsol.erase(tsol.begin()+i, tsol.begin()+N);
        	lsol.erase(lsol.begin()+i, lsol.begin()+N);
        	lamsol.erase(lamsol.begin()+i, lamsol.begin()+N);
        	ysol.erase(ysol.begin()+i, ysol.begin()+N);
        	esol.erase(esol.begin()+i, esol.begin()+N);
        	cout << "ends snipped" << endl;
        	break;
        }
	}
	// Need to interpolate e(t), t(e), l(e), lam(e), y(e)
	int size = ysol.size();
	//convert the solutions to things gsl takes
	double *esol_mat, *ysol_mat, *lsol_mat, *tsol_mat, *lamsol_mat;
	esol_mat = (double*)malloc(sizeof(double) * size);
	ysol_mat = (double*)malloc(sizeof(double) * size);
	lsol_mat = (double*)malloc(sizeof(double) * size);
	tsol_mat = (double*)malloc(sizeof(double) * size);
	lamsol_mat = (double*)malloc(sizeof(double) * size);

	//remember that the independent variable has to be increasing or GSL will whine
	for(int i = 0; i < size; i++){
		esol_mat[i] = esol[size - i - 1];
		ysol_mat[i] = ysol[size - i - 1];
		lsol_mat[i] = lsol[size - i - 1];
		tsol_mat[i] = tsol[size - i - 1];
		lamsol_mat[i] = lamsol[size - i - 1];
	}

	gsl_spline *spline_y_e = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_e_t = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_l_e = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_lam_e = gsl_spline_alloc (gsl_interp_cspline, size);

	gsl_spline_init (spline_y_e, esol_mat, ysol_mat, size);
	gsl_spline_init (spline_l_e, esol_mat, lsol_mat, size);
	gsl_spline_init (spline_lam_e, esol_mat, lamsol_mat, size);
	cout << "past solns where e is the independent variable" << endl;
	//reverse e and t for other interpolation
	for(int i = 0; i < size; i++){
		esol_mat[i] = esol[i];
		tsol_mat[i] = tsol[i];
	}
	gsl_spline_init (spline_e_t, tsol_mat, esol_mat, size);
	free(esol_mat);
	free(tsol_mat);
	free(ysol_mat);
	free(lsol_mat);
	free(lamsol_mat);
	gsl_interp_accel *acc;
	acc = gsl_interp_accel_alloc ();


	double t0 = 0;
	double tend = tsol[size - 1];
	int len =  floor((tend - t0)*sr);
	tsol.clear();
	lsol.clear();
	lamsol.clear();
	ysol.clear();
	esol.clear();
	tsol.resize(len);
	lsol.resize(len);
	lamsol.resize(len);
	ysol.resize(len);
	esol.resize(len);

	for(int i = 0; i < len; i++){
		tsol[i] = (double) 1/sr*i;
		esol[i] = gsl_spline_eval(spline_e_t, tsol[i], acc); //get the eccentricities associated with sampling the signal at sr.
		lsol[i] = gsl_spline_eval(spline_l_e, esol[i], acc); // use them to evaluate the other functions
		lamsol[i] = gsl_spline_eval(spline_lam_e, esol[i], acc);
		ysol[i] = gsl_spline_eval(spline_y_e, esol[i], acc);
	}

	gsl_spline_free(spline_e_t);
	gsl_spline_free(spline_l_e);
	gsl_spline_free(spline_lam_e);
	gsl_spline_free(spline_y_e);
	gsl_interp_accel_free(acc);

    usol.clear();
    wsol.clear();
    usol.resize(len);
    wsol.resize(len);
    cout << "len = " << len << endl;
    for(int i = 0; i < usol.size(); i++){
    	usol[i] = get_u3PN(lsol[i], esol[i], ysol[i]);
    	wsol[i] = get_W(lsol[i], esol[i], ysol[i], usol[i]);
    }
}

///////////////////////////////////
// Maps solutions from e to t
// I don't think this really gets used
// but is general and useful for extension
///////////////////////////////////

void TaylorT4::interp_map_solns_e(){
	// Need to interpolate e(t), t(e), l(e), lam(e), y(e)
	int size = ysol.size();
	//convert the solutions to things gsl takes
	double *esol_mat, *ysol_mat, *lsol_mat, *tsol_mat, *lamsol_mat;
	esol_mat = (double*)malloc(sizeof(double) * size);
	ysol_mat = (double*)malloc(sizeof(double) * size);
	lsol_mat = (double*)malloc(sizeof(double) * size);
	tsol_mat = (double*)malloc(sizeof(double) * size);
	lamsol_mat = (double*)malloc(sizeof(double) * size);

	//remember that the independent variable has to be increasing or GSL will whine
	for(int i = 0; i < size; i++){
		esol_mat[i] = esol[size - i - 1];
		ysol_mat[i] = ysol[size - i - 1];
		lsol_mat[i] = lsol[size - i - 1];
		tsol_mat[i] = tsol[size - i - 1];
		lamsol_mat[i] = lamsol[size - i - 1];
	}

	gsl_spline *spline_y_e = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_e_t = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_l_e = gsl_spline_alloc (gsl_interp_cspline, size);
	gsl_spline *spline_lam_e = gsl_spline_alloc (gsl_interp_cspline, size);

	gsl_spline_init (spline_y_e, esol_mat, ysol_mat, size);
	gsl_spline_init (spline_l_e, esol_mat, lsol_mat, size);
	gsl_spline_init (spline_lam_e, esol_mat, lamsol_mat, size);
	cout << "past solns where e is the independent variable" << endl;
	//reverse e and t for other interpolation
	for(int i = 0; i < size; i++){
		esol_mat[i] = esol[i];
		tsol_mat[i] = tsol[i];
	}
	gsl_spline_init (spline_e_t, tsol_mat, esol_mat, size);
	free(esol_mat);
	free(tsol_mat);
	free(ysol_mat);
	free(lsol_mat);
	free(lamsol_mat);
	gsl_interp_accel *acc;
	acc = gsl_interp_accel_alloc ();


	double t0 = 0;
	double tend = tsol[size - 1];
	int len =  floor((tend - t0)*sr);
	tsol.clear();
	lsol.clear();
	lamsol.clear();
	ysol.clear();
	esol.clear();
	tsol.resize(len);
	lsol.resize(len);
	lamsol.resize(len);
	ysol.resize(len);
	esol.resize(len);

	for(int i = 0; i < len; i++){
		tsol[i] = (double) 1/sr*i;
		esol[i] = gsl_spline_eval(spline_e_t, tsol[i], acc); //get the eccentricities associated with sampling the signal at sr.
		lsol[i] = gsl_spline_eval(spline_l_e, esol[i], acc); // use them to evaluate the other functions
		lamsol[i] = gsl_spline_eval(spline_lam_e, esol[i], acc);
		ysol[i] = gsl_spline_eval(spline_y_e, esol[i], acc);
	}

	gsl_spline_free(spline_e_t);
	gsl_spline_free(spline_l_e);
	gsl_spline_free(spline_lam_e);
	gsl_spline_free(spline_y_e);
	gsl_interp_accel_free(acc);

    usol.clear();
    wsol.clear();
    usol.resize(len);
    wsol.resize(len);
    cout << "len = " << len << endl;
    for(int i = 0; i < usol.size(); i++){
    	usol[i] = get_u3PN(lsol[i], esol[i], ysol[i]);
    	wsol[i] = get_W(lsol[i], esol[i], ysol[i], usol[i]);
    }
}

////////////////////////////////////////////////////////////////////////////////////////
//  Generate a solution for the orbital dynamics in the absence of
//  radiation reaction, "ncyc" controls the number of orbits in the
//  solution
////////////////////////////////////////////////////////////////////////////////////////

void TaylorT4::sol_orb_no_RR(int ncyc){
	double y0 = 1./pow( p0, 1./2.);
	double n = ldot(y0, e0)/M;
	double omega = lamdot(y0, e0)/M;
	double tend = 2*M_PI/(n)*ncyc;
	int N =  floor(tend*sr);
	cout << "n is = " << n << endl;
	cout << "omega is = " << omega << endl;
	cout << "Fn is = " << n/(2*M_PI) << endl;
	cout << "Fw is = " << omega/(2*M_PI) << endl;

	cout << "T is = " << tend << endl;
	cout << "N is = " << N << endl;

	tsol.clear();
	lsol.clear();
	lamsol.clear();
	ysol.clear();
	esol.clear();
	tsol.resize(N);
	lsol.resize(N);
	lamsol.resize(N);
	ysol.resize(N);
	esol.resize(N);

	for(int i = 0; i < N ; i++){
		// fill solns
		tsol[i] = (double) 1/sr*i;
		lsol[i] = n*tsol[i];
		lamsol[i] = omega*tsol[i];
		esol[i] = e0;
		ysol[i] = y0;
	}

    usol.clear();
    wsol.clear();
    usol.resize(N);
    wsol.resize(N);

    for(int i = 0; i < usol.size(); i++){
    	usol[i] = get_u3PN(lsol[i], esol[i], ysol[i]);
    	wsol[i] = get_W(lsol[i], esol[i], ysol[i], usol[i]);
    }
}

////////////////////////////////////////////////////////////////////////
// Get the beginning and ending relevant orbital frequencies
////////////////////////////////////////////////////////////////////////

double TaylorT4::get_F_lambda_end(){
	double y = ysol[ysol.size() - 1];
	double e = esol[esol.size() - 1];
	double lamdotval = lamdot(y, e)/M;
	return lamdotval/(2*M_PI);
}
double TaylorT4::get_F_lambda_begin(){
	double y = ysol[0];
	double e = esol[0];
	double lamdotval = lamdot(y, e)/M;
	return lamdotval/(2*M_PI);
}
double TaylorT4::get_F_l_end(){
	double y = ysol[ysol.size() - 1];
	double e = esol[esol.size() - 1];
	double ldotval = ldot(y, e)/M;
	return ldotval/(2*M_PI);
}
double TaylorT4::get_F_l_begin(){
	double y = ysol[0];
	double e = esol[0];
	double ldotval = ldot(y, e)/M;
	return ldotval/(2*M_PI);
}

/////////////////////////////////////////////////////////
// A fast scheme for solving kepler's equation (Newtonian Order)
////////////////////////////////////////////////////////

double get_uN(double l, double e)
{
	///////////////////////
	//
	// Invert Kepler's equation l = u - e sin(u)
	// Using Mikkola's method (1987)
	// referenced Tessmer & Gopakumar 2007
	//
	///////////////////////

	double u0;                                                      // initial guess at eccentric anomaly
	double z, alpha, beta, s, w;            // auxiliary variables
	double mult;                                            // multiple number of 2pi

	int neg          = 0;                                   // check if l is negative
	int over2pi  = 0;                                       // check if over 2pi
	int overpi       = 0;                                   // check if over pi but not 2pi

	double f, f1, f2, f3, f4;                       // pieces of root finder
	double u, u1, u2, u3, u4;

        // enforce the mean anomaly to be in the domain -pi < l < pi
	if (l < 0)
	{
			neg = 1;
			l   = -l;
	}
	if (l > 2.*M_PI)
	{
		over2pi = 1;
		mult    = floor(l/(2.*M_PI));
		l          -= mult*2.*M_PI;
	}
	if (l > M_PI)
	{
		overpi = 1;
		l          = 2.*M_PI - l;
	}

	alpha = (1. - e)/(4.*e + 0.5);
	beta  = 0.5*l/(4.*e + 0.5);

	z = sqrt(beta*beta + alpha*alpha*alpha);
	if (neg == 1) z = beta - z;
	else          z = beta + z;

	// to handle nan's from negative arguments
	if (z < 0.) z = -pow(-z, 0.3333333333333333);
	else        z =  pow( z, 0.3333333333333333);

	s  = z - alpha/z;
	w  = s - 0.078*s*s*s*s*s/(1. + e);

	u0 = l + e*(3.*w - 4.*w*w*w);

	// now this initial guess must be iterated once with a 4th order Newton root finder
	f  = u0 - e*sin(u0) - l;
	f1 = 1. - e*cos(u0);
	f2 = u0 - f - l;
	f3 = 1. - f1;
	f4 = -f2;

	f2 *= 0.5;
	f3 *= 0.166666666666667;
	f4 *= 0.0416666666666667;

	u1 = -f/f1;
	u2 = -f/(f1 + f2*u1);
	u3 = -f/(f1 + f2*u2 + f3*u2*u2);
	u4 = -f/(f1 + f2*u3 + f3*u3*u3 + f4*u3*u3*u3);

	u = u0 + u4;

	if (overpi  == 1) {u = 2.*M_PI - u;}
	if (over2pi == 1) {u = 2.*M_PI*mult + u;}
	if (neg     == 1) {u = -u;}

	return u;
}

///////////////////////////////////////////////////////
// Some useful QK factors which enter the orbital dynamics
// the names here follow most paper conventions
///////////////////////////////////////////////////////

double TaylorT4::f4t(double y, double e)
{
return e*Bpow(y,4)*((15*eta*Bpow(1 - Bpow(e,2),1.5))/8. - \
(Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/8.) + \
Bpow(y,6)*(Bpow(e,3)*((-75*eta*Bpow(1 - Bpow(e,2),1.5))/16. + \
(5*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/8. - (Bpow(eta,3)*Bpow(1 - \
Bpow(e,2),1.5))/48.) + Bpow(e,-1)*((-135*eta*Bpow(1 - \
Bpow(e,2),1.5))/64. - (3*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/32. + \
(Bpow(eta,3)*Bpow(1 - Bpow(e,2),1.5))/64.) + e*((75*eta*Bpow(1 - \
Bpow(e,2),1.5))/64. - (65*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/32. + \
(25*Bpow(eta,3)*Bpow(1 - Bpow(e,2),1.5))/192.));
}
double TaylorT4::f6t(double y, double e)
{
return Bpow(y,6)*(Bpow(e,-1)*((135*eta*Bpow(1 - Bpow(e,2),1.5))/64. + \
(3*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/32. - (Bpow(eta,3)*Bpow(1 - \
Bpow(e,2),1.5))/64.) + Bpow(e,3)*((297*eta*Bpow(1 - \
Bpow(e,2),1.5))/64. - (175*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/64. + \
(23*Bpow(eta,3)*Bpow(1 - Bpow(e,2),1.5))/64.) + e*(10*Bpow(1 - \
Bpow(e,2),1.5) - (215*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/32. - \
(11*Bpow(eta,3)*Bpow(1 - Bpow(e,2),1.5))/64. - (eta*(-28531 + \
1435*Bpow(M_PI,2))*Bpow(1 - Bpow(e,2),1.5))/2240.));
}
double TaylorT4::g4t(double y, double e)
{
return Bpow(y,4)*((15*Bpow(1 - Bpow(e,2),1.5))/2. - 3*eta*Bpow(1 - \
Bpow(e,2),1.5)) + Bpow(y,6)*((-315*Bpow(1 - Bpow(e,2),1.5))/16. + \
(91*eta*Bpow(1 - Bpow(e,2),1.5))/16. + (7*Bpow(eta,2)*Bpow(1 - \
Bpow(e,2),1.5))/8. + Bpow(e,2)*((-45*Bpow(1 - Bpow(e,2),1.5))/16. - \
(67*eta*Bpow(1 - Bpow(e,2),1.5))/16. + (17*Bpow(eta,2)*Bpow(1 - \
Bpow(e,2),1.5))/8.));
}
double TaylorT4::g6t(double y, double e)
{
return Bpow(y,6)*((555*Bpow(1 - Bpow(e,2),1.5))/16. + \
(33*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/8. + (41*eta*(-292 + \
3*Bpow(M_PI,2))*Bpow(1 - Bpow(e,2),1.5))/192. + Bpow(e,2)*((285*Bpow(1 \
- Bpow(e,2),1.5))/16. - (165*eta*Bpow(1 - Bpow(e,2),1.5))/16. + \
(27*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/8.));
}
double TaylorT4::i6t(double y, double e)
{
return Bpow(e,2)*Bpow(y,6)*((29*eta*Bpow(1 - Bpow(e,2),1.5))/4. - \
(49*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/16. + (3*Bpow(eta,3)*Bpow(1 \
- Bpow(e,2),1.5))/16.);
}
double TaylorT4::h6t(double y, double e)
{
return Bpow(e,3)*Bpow(y,6)*((23*eta*Bpow(1 - Bpow(e,2),1.5))/192. - \
(73*Bpow(eta,2)*Bpow(1 - Bpow(e,2),1.5))/192. + \
(13*Bpow(eta,3)*Bpow(1 - Bpow(e,2),1.5))/192.);
}

////////////////////////////////////////////////
// A series solution to get v (true anomaly)
////////////////////////////////////////////////

double TaylorT4::get_v(double y, double e, double u){
	double factor;
	double tanu_over2 = tan(u/2.);

	factor = (-0.9999999999999999 + 3.*Bpow(e,2) - 3.*Bpow(e,4) + 0.9999999999999994*Bpow(e,6))*Bpow((1. + 1.*e)*Bpow(1. - 1.*e,-1),0.5)*Bpow(-1. + 1.*Bpow(e,2),-3) +
			   (-3.999999999999998*e + 1.*e*eta + 12.*Bpow(e,3) - 3.*eta*Bpow(e,3) - 12.*Bpow(e,5) + 3.*eta*Bpow(e,5) + 3.999999999999998*Bpow(e,7) - 1.*eta*Bpow(e,7))*Bpow(y,2)*Bpow((1. + 1.*e)*Bpow(1. - 1.*e,-1),0.5)*
			    Bpow(-1. + 1.*Bpow(e,2),-3) + (7.999999999999996*Bpow(e,8) - 4.*eta*Bpow(e,8) + 1.9492187500000124*Bpow(e,9) - 0.3151041666666621*eta*Bpow(e,9) - 0.20507812500001013*Bpow(e,11) +
			      0.0820312499999911*eta*Bpow(e,11) - 0.051269531249989356*Bpow(e,13) + 0.020507812500008875*eta*Bpow(e,13) - 0.018310546875007556*Bpow(e,15) + 0.007324218749995565*eta*Bpow(e,15) -
			      0.008010864257807606*Bpow(e,17) + 0.0032043457031258864*eta*Bpow(e,17) - 0.004005432128911139*Bpow(e,19) + 0.0016021728515624996*eta*Bpow(e,19) - 0.0022029876708939944*Bpow(e,21) +
			      0.0008811950683593747*eta*Bpow(e,21) - 1.6263032587282567e-18*Bpow(e,22) - 0.001301765441896752*Bpow(e,23) + 0.0005207061767587013*eta*Bpow(e,23) + 1.6263032587282567e-18*Bpow(e,24) -
			      0.0008136034011831943*Bpow(e,25) + 0.0003254413604709687*eta*Bpow(e,25) + 2.1618256568908674*Bpow(e,27) + 5.691519737243653*eta*Bpow(e,27) - 6.528946638107296*Bpow(e,29) - 17.057171344757077*eta*Bpow(e,29) +
			      4.163336342344336e-16*Bpow(e,30) + 6.573997020721433*Bpow(e,31) + 17.039151191711422*eta*Bpow(e,31) - 4.163336342344337e-16*Bpow(e,32) - 2.2088519334793086*Bpow(e,33) - 5.6727092266082755*eta*Bpow(e,33) +
			      Bpow(e,7)*(17.40624999999998 - 3.864583333333335*eta - 1.7604166666666667*Bpow(eta,2)) + Bpow(e,6)*(-23.999999999999996 + 11.999999999999996*eta - 1.5*Bpow(eta,2)) +
			      Bpow(e,3)*(61.24999999999999 - 11.489583333333332*eta - 0.6979166666666666*Bpow(eta,2)) + Bpow(e,2)*(-7.999999999999996 + 4.*eta - 0.5*Bpow(eta,2)) +
			      e*(-20.5 + 3.7083333333333335*eta + 0.041666666666666664*Bpow(eta,2)) + 0.5*Bpow(e,8)*Bpow(eta,2) + 0.5729166666666667*Bpow(e,9)*Bpow(eta,2) - 0.46875*Bpow(e,27)*Bpow(eta,2) + 1.40625*Bpow(e,29)*Bpow(eta,2) -
			      1.40625*Bpow(e,31)*Bpow(eta,2) + 0.46875*Bpow(e,33)*Bpow(eta,2) + Bpow(e,4)*(23.999999999999996 - 11.999999999999996*eta + 1.5*Bpow(eta,2)) + Bpow(e,5)*(-59.81249999999997 + 11.84375*eta + 1.84375*Bpow(eta,2)))*
			    Bpow(y,4)*Bpow((1. + 1.*e)*Bpow(1. - 1.*e,-1),0.5)*Bpow(-1. + 1.*Bpow(e,2),-3) + (-2.842170943040401e-14*Bpow(e,36) + e*(-119.00000000000001 + 176.0182598372948*eta + 0.29166666666666674*Bpow(eta,2)) +
			      Bpow(e,29)*(-1100.2522253990164 + 5343.446887605009*eta + 1193.7316535313912*Bpow(eta,2) - 33.08593749999998*Bpow(eta,3)) +
			      Bpow(e,33)*(-1036.104166746139 + 5250.285897387976*eta + 1114.9625366528828*Bpow(eta,2) - 29.882812499999993*Bpow(eta,3)) +
			      Bpow(e,6)*(-239.2499999999999 + 107.18749999999973*eta - 4.468750000000011*Bpow(eta,2) - 1.8437500000000004*Bpow(eta,3)) +
			      Bpow(e,7)*(-93.18749999999955 - 144.88979950110252*eta + 23.24739583333335*Bpow(eta,2) - 1.4140625000000022*Bpow(eta,3)) +
			      Bpow(e,30)*(-26.115786552429327 - 61.69973874092012*eta + 22.68217134475765*Bpow(eta,2) - 1.406249999999993*Bpow(eta,3)) +
			      Bpow(e,10)*(7.796874999999972 - 3.209635416666842*eta + 2.6067708333333393*Bpow(eta,2) - 0.5729166666666669*Bpow(eta,3)) +
			      Bpow(e,34)*(-8.835407733917238 - 20.481984972953345*eta + 7.547709226608277*Bpow(eta,2) - 0.4687500000000018*Bpow(eta,3)) +
			      Bpow(e,3)*(304.5000000000001 - 537.5972668318224*eta + 11.151041666666666*Bpow(eta,2) - 0.2864583333333334*Bpow(eta,3)) +
			      Bpow(e,11)*(-8.61328125000023 + 9.671514294649487*eta - 2.209635416666705*Bpow(eta,2) - 0.18489583333333084*Bpow(eta,3)) +
			      Bpow(e,2)*(-81.99999999999999 + 35.33333333333336*eta - 3.541666666666666*Bpow(eta,2) - 0.041666666666666664*Bpow(eta,3)) +
			      Bpow(e,21)*(-0.0324440002445367 + 0.035549103752839206*eta - 0.006408691406341059*Bpow(eta,2) - 1.6218146617341667e-14*Bpow(eta,3)) +
			      Bpow(e,24)*(-0.005207061767589947 + 0.00338459014911116*eta - 0.0005207061768781812*Bpow(eta,2) - 5.778797579347739e-15*Bpow(eta,3)) +
			      Bpow(e,15)*(-0.3295898437503851 + 0.3458104280911718*eta - 0.06884765625016512*Bpow(eta,2) - 5.776629175002768e-15*Bpow(eta,3)) +
			      Bpow(e,14)*(-0.20507812500010145 + 0.13330078125047695*eta - 0.02050781250003026*Bpow(eta,2) - 2.7201006204402578e-15*Bpow(eta,3)) +
			      Bpow(e,13)*(-1.1279296874996823 + 1.1405348236649593*eta - 0.2460937499998329*Bpow(eta,2) - 2.6089698977604936e-15*Bpow(eta,3)) +
			      Bpow(e,20)*(-0.016021728515607965 + 0.010414123535474211*eta - 0.001602172851671746*Bpow(eta,2) - 2.2234818153332717e-15*Bpow(eta,3)) +
			      Bpow(e,16)*(-0.07324218749984411 + 0.04760742187475362*eta - 0.007324218749961941*Bpow(eta,2) + 1.335737076502139e-15*Bpow(eta,3)) +
			      Bpow(e,12)*(-0.8203124999999777 + 0.5332031249997748*eta - 0.08203124999998634*Bpow(eta,2) + 1.4836764629377885e-15*Bpow(eta,3)) +
			      Bpow(e,18)*(-0.032043457031308585 + 0.020828247070247677*eta - 0.00320434570313133*Bpow(eta,2) + 1.7724537115793034e-15*Bpow(eta,3)) +
			      Bpow(e,22)*(-0.008811950683673693 + 0.0057277679441028505*eta - 0.0008811950681546364*Bpow(eta,2) + 2.0072919021396613e-15*Bpow(eta,3)) +
			      Bpow(e,19)*(-0.06141662597621897 + 0.06667386317340329*eta - 0.012283325195432404*Bpow(eta,2) + 3.999838654733523e-15*Bpow(eta,3)) +
			      Bpow(e,23)*(-0.01862525939977349 + 0.020547484539786467*eta - 0.003644943236389392*Bpow(eta,2) + 5.778797579347736e-15*Bpow(eta,3)) +
			      Bpow(e,26)*(-0.0032544136045774257 + 0.002115368842638296*eta - 0.0003254413604081498*Bpow(eta,2) + 8.436393944544207e-15*Bpow(eta,3)) +
			      Bpow(e,17)*(-0.13046264648418665 + 0.13975641776259873*eta - 0.02655029296865037*Bpow(eta,2) + 9.77386574452232e-15*Bpow(eta,3)) +
			      Bpow(e,25)*(-0.011390447615556527 + 0.012631892640442068*eta - 0.002213001253104273*Bpow(eta,2) + 1.1103531288858548e-14*Bpow(eta,3)) +
			      Bpow(e,28)*(8.64730262756347 + 20.604253292083428*eta - 7.566519737243845*Bpow(eta,2) + 0.46874999999999245*Bpow(eta,3)) +
			      Bpow(e,4)*(244.9999999999999 - 107.20833333333327*eta + 8.697916666666663*Bpow(eta,2) + 0.6979166666666667*Bpow(eta,3)) +
			      Bpow(e,9)*(96.91406249999996 - 39.15653290716638*eta - 1.565104166666707*Bpow(eta,2) + 0.8411458333333341*Bpow(eta,3)) +
			      Bpow(e,5)*(-178.87500000000048 + 534.1626850532958*eta - 30.54427083333335*Bpow(eta,2) + 1.0442708333333341*Bpow(eta,3)) +
			      Bpow(e,32)*(26.295988082885522 + 61.58260774612428*eta - 22.664151191711653*Bpow(eta,2) + 1.4062499999999964*Bpow(eta,3)) +
			      Bpow(e,8)*(69.62499999999991 - 32.86458333333298*eta - 3.177083333333347*Bpow(eta,2) + 1.7604166666666665*Bpow(eta,3)) +
			      Bpow(e,35)*(250.8556869029997 - 1300.752850903048*eta - 268.92274983723956*Bpow(eta,2) + 7.070312499999997*Bpow(eta,3)) +
			      Bpow(e,27)*(282.9516370296468 - 1347.3584563301288*eta - 308.30324490864865*Bpow(eta,2) + 8.671874999999979*Bpow(eta,3)) +
			      Bpow(e,31)*(1602.5226454734793 - 7945.59184171858*eta - 1731.4732475280755*Bpow(eta,2) + 47.22656249999998*Bpow(eta,3)))*Bpow(y,6)*Bpow((1. + 1.*e)*Bpow(1. - 1.*e,-1),0.5)*Bpow(-1. + 1.*Bpow(e,2),-3);
	return  2*atan(factor*tanu_over2);
}

///////////////////////////////////////////////////////
// Some useful QK factors which enter the orbital dynamics
// the names here follow most paper conventions
///////////////////////////////////////////////////////

double TaylorT4::f4p(double y, double e)
{
return Bpow(e,2)*(0.125 + (19*eta)/8. - (3*Bpow(eta,2))/8.)*Bpow(y,4) \
+ (-0.28125 - (43*eta)/8. + Bpow(eta,2)/4. + Bpow(e,4)*(0.21875 + \
(95*eta)/24. - (53*Bpow(eta,2))/12. + (19*Bpow(eta,3))/32.) + \
Bpow(e,2)*(0.0625 + (11*eta)/12. - (16*Bpow(eta,2))/3. + \
(13*Bpow(eta,3))/16.) + (3*Bpow(eta,3))/32.)*Bpow(y,6);
}
double TaylorT4::f6p(double y, double e)
{
return (0.28125 + (43*eta)/8. - Bpow(eta,2)/4. + Bpow(e,4)*(0.03125 + \
(253*eta)/48. - (119*Bpow(eta,2))/32. + (3*Bpow(eta,3))/8.) - \
(3*Bpow(eta,3))/32. + Bpow(e,2)*(2.1875 - (17*Bpow(eta,2))/2. - \
(7*Bpow(eta,3))/16. + (eta*(708544 - \
30135*Bpow(M_PI,2)))/26880.))*Bpow(y,6);
}
double TaylorT4::g4p(double y, double e)
{
return Bpow(e,3)*(eta/32. - (3*Bpow(eta,2))/32.)*Bpow(y,4) + \
(e*((-27*eta)/256. + (39*Bpow(eta,2))/128. + (9*Bpow(eta,3))/256.) + \
Bpow(e,5)*((-3*eta)/256. + (5*Bpow(eta,2))/384. + \
(17*Bpow(eta,3))/256.) + Bpow(e,3)*((15*eta)/128. - \
(85*Bpow(eta,2))/192. + (35*Bpow(eta,3))/128.))*Bpow(y,6);
}
double TaylorT4::g6p(double y, double e)
{
return (e*((27*eta)/256. - (39*Bpow(eta,2))/128. - \
(9*Bpow(eta,3))/256.) + Bpow(e,5)*((7*eta)/128. - \
(49*Bpow(eta,2))/256. + (13*Bpow(eta,3))/128.) + \
Bpow(e,3)*((-43*Bpow(eta,2))/16. - Bpow(eta,3)/128. + (eta*(34726 - \
1435*Bpow(M_PI,2)))/8960.))*Bpow(y,6);
}
double TaylorT4::i6p(double y, double e)
{
return Bpow(e,4)*((41*eta)/96. - (19*Bpow(eta,2))/64. + \
(5*Bpow(eta,3))/64.)*Bpow(y,6);
}
double TaylorT4::h6p(double y, double e)
{
return Bpow(e,5)*(eta/256. - (5*Bpow(eta,2))/256. + \
(5*Bpow(eta,3))/256.)*Bpow(y,6);
}

/////////////////////////////////////////////////////////
// A fast scheme for solving kepler's equation (3PN Order)
////////////////////////////////////////////////////////

double TaylorT4::get_u3PN(double l, double e, double y){
	double u0PN = get_uN(l, e);
	double v = get_v(y, e, u0PN);
	double mult = round((u0PN)/(2.*M_PI));
	double l4 = (g4t(y,e) + g6t(y,e))*(v + 2*M_PI*mult - u0PN) + (f4t(y, e) + f6t(y,e))*sin(v) + i6t(y, e)*sin(2*v) + h6t(y, e)*sin(3*v);
	double lp = l-l4;
	double uPN = get_uN(lp, e);

	return uPN;
}

////////////////////////////////////////////////////////
// This checks the solution to keplers equation
// should output a ton of zeros (or close to zero)
////////////////////////////////////////////////////////

void TaylorT4::check_keplers(){
	int N = ysol.size();
	double v = 0;
	double chk = 0;
	double u0pn = 0;
	double mult = 0;
	for (int i = 0; i < N; i++){
		u0pn = get_uN(lsol[i], esol[i]);
		v = get_v(ysol[i], esol[i], u0pn);
		mult = floor(u0pn/(2.*M_PI));
		chk = lsol[i] - (usol[i]-esol[i]*sin(usol[i]) + (g4t(ysol[i],esol[i])
				+ g6t(ysol[i],esol[i]))*(v + 2*M_PI*mult - usol[i]) + (f4t(ysol[i], esol[i]) + f6t(ysol[i],esol[i]))*sin(v)
				+ i6t(ysol[i], esol[i])*sin(2*v) + h6t(ysol[i], esol[i])*sin(3*v));
	cout << "Inserting solution of u into keplers equation yeilds = " << chk << endl;
	}
}

////////////////////////////////////////////////////////////
// Solution for oscillatory term W
////////////////////////////////////////////////////////////

double TaylorT4::get_W(double l, double e, double y, double u){
	double v = get_v(y, e, u);
	double term;

	term = (v-u+e*sin(u)) + (f4p(y,e) +f6p(y,e))*sin(2*v) + (g4p(y,e) + g6p(y, e))*sin(3*v) + i6p(y,e)*sin(4*v) + h6p(y,e)*sin(5*v);
	return term;
}

////////////////////////////////////////////////////////////////
// Solves orbit and fills u and W solutions as well
////////////////////////////////////////////////////////////////

void TaylorT4::fill_all(){
	solorb();
	int N = ysol.size();
    usol.clear();
    wsol.clear();
    usol.resize(N);
    wsol.resize(N);

    for(int i = 0; i < usol.size(); i++){
    	usol[i] = get_u3PN(lsol[i], esol[i], ysol[i]);
    	wsol[i] = get_W(lsol[i], esol[i], ysol[i], usol[i]);
    }
}

////////////////////////////////////////////////////////////////
// Getters for the orbital solutions
////////////////////////////////////////////////////////////////

vector<double> TaylorT4::get_esol(){
	return esol;
}
vector<double> TaylorT4::get_ysol(){
	return ysol;
}
vector<double> TaylorT4::get_lamsol(){
	return lamsol;
}
vector<double> TaylorT4::get_lsol(){
	return lsol;
}
vector<double> TaylorT4::get_hsol(){
	return hsol;
}
vector<double> TaylorT4::get_tsol(){
	return tsol;
}

//Sols for the frequencies
vector<double> TaylorT4::get_fnsol(){
	int N = ysol.size();
	vector<double> vect(N);
	for(int i = 0; i < N; i++){
		vect[i] = ldot(ysol[i], esol[i])/(2*M_PI*M);
	}

	return vect;
}
vector<double> TaylorT4::get_fwsol(){
	int N = ysol.size();
	vector<double> vect(N);
	for(int i = 0; i < N; i++){
		vect[i] = lamdot(ysol[i], esol[i])/(2*M_PI*M);
	}

	return vect;
}
//Sol for r(t)
vector<double> TaylorT4::get_rsol(){
	vector<double> nsol = get_fnsol();
	vector<double> r(nsol.size());

	for(int i = 0; i < nsol.size(); i++){
		r[i] = pow(M/(4*M_PI*M_PI*nsol[i]*nsol[i]), 1./3.)*(1-esol[i]*cos(usol[i]))/M;
	}
	return r;
}
//Sol for phi(t)
vector<double> TaylorT4::get_phisol(){
	vector<double> phi(lamsol.size());

	for(int i = 0; i < lamsol.size(); i++){
		phi[i] = lamsol[i] + wsol[i];
	}
	return phi;
}

///////////////////////////////////////////////////////////////
// The below functions are the PN amplitudes provided in
// Gopu's 2PN eccentric amplitudes paper
// They follow the convention there.
// Due to the length of these, many have been relegated to
// TD_PN_Amps.hpp
///////////////////////////////////////////////////////////////

double TaylorT4::P_0_C_2_C_2(double e, double u){
	double ecosu = e*cos(u);
	double C = cos(iota);
	double term;

	term = 1./Bpow(1-ecosu, 2)*((1+C*C)*(ecosu*ecosu-ecosu-2*e*e+2));
	return term;
}
double TaylorT4::P_0_C_2_S_2(double e, double u){
	double ecosu = e*cos(u);
	double esinu = e*sin(u);
	double C = cos(iota);
	double term;

	term = 2./Bpow(1-ecosu, 2)*((1+C*C)*Bpow(1-e*e,1./2.)*esinu);
	return term;
}
double TaylorT4::P_0(double e, double u){
	double S = sin(iota);
	double ecosu = e*cos(u);
	double term;

	term = S*S/(1-ecosu)*ecosu;
	return term;
}
double TaylorT4::X_0_C_2_C_2(double e, double u){
	double ecosu = e*cos(u);
	double esinu = e*sin(u);
	double C = cos(iota);
	double term;

	term = -4*C*Bpow(1-e*e,1./2.)*Bpow(1-ecosu,-2)*esinu;
	return term;
}
double TaylorT4::X_0_C_2_S_2(double e, double u){
	double ecosu = e*cos(u);
	double C = cos(iota);
	double term;

	term = 2*C*Bpow(1-ecosu,-2)*(ecosu*ecosu-ecosu-2*(e*e-1));
	return term;
}
double TaylorT4::H_P_0(double e, double u, double c2w, double s2w, double c2lam, double s2lam){
	double P0C2C2 =  P_0_C_2_C_2(e, u);
	double P0C2S2 =  P_0_C_2_S_2(e, u);
	double P0 = P_0(e, u);
	double term;

	term = (P0C2C2*c2w+P0C2S2*s2w)*c2lam+(P0C2S2*c2w-P0C2C2*s2w)*s2lam+P0;
	return term;
}
double TaylorT4::H_X_0(double e, double u, double c2w, double s2w, double c2lam, double s2lam){
	double X0C2C2 = X_0_C_2_C_2(e, u);
	double X0C2S2 = X_0_C_2_S_2(e, u);
	double term;

	term = (X0C2C2*c2w+X0C2S2*s2w)*c2lam+(X0C2S2*c2w-X0C2C2*s2w)*s2lam;
	return term;
}
double TaylorT4::F_p(double thet, double phi, double psi){
	double fp;

	fp = 1./2.*(1+cos(thet)*cos(thet))*cos(2*phi)*cos(2*psi)-cos(thet)*sin(2*phi)*sin(2*psi);
	return fp;
}
double TaylorT4::F_c(double thet, double phi, double psi){
	return F_p(thet, phi, psi-M_PI/4);
}

////////////////////////////////////////////////////////////
// below is h(t) for various PN orders indicated next to "h"
// i.e. h_05 is the amplitude including effects up to .5PN
////////////////////////////////////////////////////////////

double TaylorT4::h_0(double y, double e, double u, double w, double lam){
	double h;
	double c2w = cos(2*w);
	double s2w = sin(2*w);
	double c2lam = cos(2*lam);
	double s2lam = sin(2*lam);
	double amp = M*eta/DL*y*y*(1-e*e);

	h = (H_P_0(e, u, c2w, s2w, c2lam, s2lam)*F_p(thet, phi, psi) + H_X_0(e, u, c2w, s2w, c2lam, s2lam)*F_c(thet, phi, psi));
	return h*amp;
}
double TaylorT4::h_05(double y, double e, double u, double w, double lam){
	double amp = M*eta/DL*y*y*(1-e*e);
	double h;
	double fp = F_p(thet, phi, psi);
	double fc = F_c(thet, phi, psi);
	double m1 = 1./2.*(M + Bpow(M*M-4*M*M*eta, 0.5));
	double m2 = 1./2.*(M - Bpow(M*M-4*M*M*eta, 0.5));

	h = h_0(y,e,u,w,lam) + amp*y*Bpow(1-e*e, 0.5)*(fp*H_P_05(e, u, w, lam, iota, m1, m2) + fc*H_X_05(e, u, w, lam, iota, m1, m2));
	return h;
}
double TaylorT4::h_1(double y, double e, double u, double w, double lam){
	double amp = M*eta/DL*y*y*(1-e*e);
	double h;
	double fp = F_p(thet, phi, psi);
	double fc = F_c(thet, phi, psi);
	double c2w = cos(2*w);
	double s2w = sin(2*w);
	double c2lam = cos(2*lam);
	double s2lam = sin(2*lam);
	double HP0 = H_P_0(e, u, c2w, s2w, c2lam, s2lam);
	double HX0 = H_X_0(e, u, c2w, s2w, c2lam, s2lam);
	double HP1 = H_P_1(e, u, w, lam, iota, eta);
	double HX1 = H_X_1(e, u, w, lam, iota, eta);

	h =  h_05(y,e,u,w,lam) + amp*y*y*(fp*HP0 + fc*HX0 + (1-e*e)*(fp*HP1 + fc*HX1));
	return h;
}
double TaylorT4::h_15(double y, double e, double u, double w, double lam){
	double amp = M*eta/DL*y*y*(1-e*e);
	double h;
	double fp = F_p(thet, phi, psi);
	double fc = F_c(thet, phi, psi);
	double m1 = 1./2.*(M + Bpow(M*M-4*M*M*eta, 0.5));
	double m2 = 1./2.*(M - Bpow(M*M-4*M*M*eta, 0.5));
	double HP05 = H_P_05(e, u, w, lam, iota, m1, m2);
	double HX05 = H_X_05(e, u, w, lam, iota, m1, m2);
	double HP15 = H_P_15(e, u, w, lam, iota, m1, m2, eta);
	double HX15 = H_X_15(e, u, w, lam, iota, m1, m2, eta);

	h = h_1(y,e,u,w,lam) + amp*y*y*y*Bpow(1-e*e, 0.5)*(-3*(fp*HP05 + fc*HX05) + (1-e*e)*(fp*HP15 + fc*HX15));
	return h;
}
double TaylorT4::h_2(double y, double e, double u, double w, double lam){
	double amp = M*eta/DL*y*y*(1-e*e);
	double h;
	double fp = F_p(thet, phi, psi);
	double fc = F_c(thet, phi, psi);
	double c2w = cos(2*w);
	double s2w = sin(2*w);
	double c2lam = cos(2*lam);
	double s2lam = sin(2*lam);
	double HP0 = H_P_0(e, u, c2w, s2w, c2lam, s2lam);
	double HX0 = H_X_0(e, u, c2w, s2w, c2lam, s2lam);
	double H0 = fp*HP0 + fc*HX0;
	double HP1 = H_P_1(e, u, w, lam, iota, eta);
	double HX1 = H_X_1(e, u, w, lam, iota, eta);
	double H1 =fp*HP1 + fc*HX1;
	double HP2 = H_P_2(e, u, w, lam, iota, eta);
	double HX2 = H_X_2(e, u, w, lam, iota, eta);
	double H2 = (fp*HP2 + fc*HX2);

	h = h_15(y,e,u,w,lam) + amp*pow(y, 4.)*(4*(e*e-1)*H1 + (1 - 2*e*e + pow(e,4))*H2 + (-4 - 17./2.*e*e + 14./3.*eta + 13./3.*e*e*eta)*H0);
	return h;
}

//Solve h(t), vectorized, at 0PN

void TaylorT4::sol_h(){
	fill_all();
//	cout << "reached sol_h(), sol'd orb" << endl;
	int N = ysol.size();
	hsol.clear();
	hsol.resize(N);
	for(int i = 0; i < N; i++){
		hsol[i] = h_0(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
}

//Solve h(t), vectorized, at "pn" order (up to 2)

void TaylorT4::sol_h_pn(int pn){
	fill_all();
//	cout << "reached sol_h(), sol'd orb" << endl;
	int N = ysol.size();
	hsol.clear();
	hsol.resize(N);
	if(pn == 0){
	for(int i = 0; i < N; i++){
		hsol[i] = h_0(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
	}
	else if(pn == 1){
	for(int i = 0; i < N; i++){
		hsol[i] = h_05(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
	}
	else if(pn == 2){
	for(int i = 0; i < N; i++){
		hsol[i] = h_1(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
	}
	else if(pn == 3){
	for(int i = 0; i < N; i++){
		hsol[i] = h_15(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
	}
	else if(pn == 4){
	for(int i = 0; i < N; i++){
		hsol[i] = h_2(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
	}
	else{
		cout << "Improper PN specified" << endl;
	}
}

//Solve h(t), vectorized, at 0PN, but using
//the ODEs w/ e as the independent variable

void TaylorT4::sol_h_e(){
	sol_orb_e_param();
//	cout << "reached sol_h(), sol'd orb" << endl;
	int N = ysol.size();
	hsol.clear();
	hsol.resize(N);
	for(int i = 0; i < N; i++){
		hsol[i] = h_0(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
}

//Solve h(t) in the absence of RR

void TaylorT4::sol_h(int ncyc){
	sol_orb_no_RR(ncyc);
//	cout << "reached sol_h(), sol'd orb" << endl;
	int N = ysol.size();
	hsol.clear();
	hsol.resize(N);
	for(int i = 0; i < N; i++){
		hsol[i] = h_0(ysol[i], esol[i], usol[i], wsol[i], lamsol[i]);
	}
}

// Pad the different h(t) solutions with zeros such that it is
// a length which is 2^N w/ N an int

vector<double> TaylorT4::pad_h(){
	sol_h();
//	cout << "sol h complete" << endl;
	int N = hsol.size();
	int K = pow(2, ceil(log2((double) N)));
	int padL = ceil((double) (K-N)/2);
	vector<double> paddedht (K);

	for(int i = padL - 1; i < hsol.size() + padL - 1 ; i++){
		paddedht[i] = hsol[i - (padL - 1)];
	}
	return paddedht;
}
vector<double> TaylorT4::pad_h_e(){
	sol_h_e();
//	cout << "sol h complete" << endl;
	int N = hsol.size();
	int K = pow(2, ceil(log2((double) N)));
	int padL = ceil((double) (K-N)/2);
	vector<double> paddedht (K);

	for(int i = padL - 1; i < hsol.size() + padL - 1 ; i++){
		paddedht[i] = hsol[i - (padL - 1)];
	}
	return paddedht;
}
vector<double> TaylorT4::pad_h(int ncyc){
	sol_h(ncyc);
//	cout << "sol h complete" << endl;
	int N = hsol.size();
	int K = pow(2, ceil(log2((double) N)));
	int padL = ceil((double) (K-N)/2);
	vector<double> paddedht (K);

	for(int i = padL - 1; i < hsol.size() + padL - 1 ; i++){
		paddedht[i] = hsol[i - (padL - 1)];
	}
	return paddedht;
}
vector<double> TaylorT4::pad_h_pn(int pn){
	sol_h_pn(pn);
//	cout << "sol h complete" << endl;
	int N = hsol.size();
	int K = pow(2, ceil(log2((double) N)));
	int padL = ceil((double) (K-N)/2);
	vector<double> paddedht (K);

	for(int i = padL - 1; i < hsol.size() + padL - 1 ; i++){
		paddedht[i] = hsol[i - (padL - 1)];
	}
	return paddedht;
}

//Pad with a Hann window

vector<double> TaylorT4::pad_h_hann(){
	sol_h();
//	cout << "sol h complete" << endl;
	int N = hsol.size();

	//apply hann window
	for(int i = 0; i < N; i++){
		hsol[i] = hsol[i]*sin(M_PI*i/(N - 1))*sin(M_PI*i/(N - 1));
	}

	int K = pow(2, ceil(log2((double) N)));
	int padL = ceil((double) (K-N)/2);
	vector<double> paddedht (K);

	for(int i = padL - 1; i < hsol.size() + padL - 1 ; i++){
		paddedht[i] = hsol[i - (padL - 1)];
	}
	return paddedht;
}

//These make the DFTs of the above h(t)s following
//that naming convention

void TaylorT4::make_T4(){
//	cout << "calling make T4" << endl;
	vector<double> tser = pad_h();
//	cout << "padded" << endl;
    fftw_complex *in, *out; // init the data types fftw needs
    fftw_plan p; // init a plan
    int N = tser.size(); // size of arrays
//    cout << N << endl;
    vector<vector<double> > vect(N/2, vector<double>(3)); // a vector which will hold T4 {f, Re, Im}

    in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // initialize input and output
    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);


    //fill input with h
    for(int i = 0; i < N; i++){
    	in[i][0] = tser[i];
        in[i][1] = 0;       // should be in[i][0] = tser[i];
    }
    p = fftw_plan_dft_1d(N, in, out, FFTW_BACKWARD, FFTW_ESTIMATE); // make the plan
    //compute dft
    fftw_execute(p);
    //deallocate mem from plan
    fftw_destroy_plan(p);
    // make the output a vector
    for(int i = 0; i < N/2; i++){
    	vect[i][0] = (double) i*sr/N;
    	vect[i][1] = out[i][0]*1./sr;
    	vect[i][2] = out[i][1]*1./sr;
    }
    //deallocate memory from in and out
    fftw_free(in); fftw_free(out);

    //assign output to member variable
    h_T4_f = vect;
}
void TaylorT4::make_T4_pn(int pn){
//	cout << "calling make T4" << endl;
	vector<double> tser = pad_h_pn(pn);
//	cout << "padded" << endl;
    fftw_complex *in, *out; // init the data types fftw needs
    fftw_plan p; // init a plan
    int N = tser.size(); // size of arrays
//    cout << N << endl;
    vector<vector<double> > vect(N/2, vector<double>(3)); // a vector which will hold T4 {f, Re, Im}

    in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // initialize input and output
    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);


    //fill input with h
    for(int i = 0; i < N; i++){
    	in[i][0] = tser[i];
        in[i][1] = 0;       // should be in[i][0] = tser[i];
    }
    p = fftw_plan_dft_1d(N, in, out, FFTW_BACKWARD, FFTW_ESTIMATE); // make the plan
    //compute dft
    fftw_execute(p);
    //deallocate mem from plan
    fftw_destroy_plan(p);
    // make the output a vector
    for(int i = 0; i < N/2; i++){
    	vect[i][0] = (double) i*sr/N;
    	vect[i][1] = out[i][0]*1./sr;
    	vect[i][2] = out[i][1]*1./sr;
    }
    //deallocate memory from in and out
    fftw_free(in); fftw_free(out);

    //assign output to member variable
    h_T4_f = vect;
}
void TaylorT4::make_T4_e(){
//	cout << "calling make T4" << endl;
	vector<double> tser = pad_h_e();
//	cout << "padded" << endl;
    fftw_complex *in, *out; // init the data types fftw needs
    fftw_plan p; // init a plan
    int N = tser.size(); // size of arrays
//    cout << N << endl;
    vector<vector<double> > vect(N/2, vector<double>(3)); // a vector which will hold T4 {f, Re, Im}

    in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // initialize input and output
    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);


    //fill input with h
    for(int i = 0; i < N; i++){
    	in[i][0] = tser[i];
        in[i][1] = 0;       // should be in[i][0] = tser[i];
    }
    p = fftw_plan_dft_1d(N, in, out, FFTW_BACKWARD, FFTW_ESTIMATE); // make the plan
    //compute dft
    fftw_execute(p);
    //deallocate mem from plan
    fftw_destroy_plan(p);
    // make the output a vector
    for(int i = 0; i < N/2; i++){
    	vect[i][0] = (double) i*sr/N;
    	vect[i][1] = out[i][0]*1./sr;
    	vect[i][2] = out[i][1]*1./sr;
    }
    //deallocate memory from in and out
    fftw_free(in); fftw_free(out);

    //assign output to member variable
    h_T4_f = vect;
}
void TaylorT4::make_T4(int ncyc){
//	cout << "calling make T4" << endl;
	vector<double> tser = pad_h(ncyc);
//	cout << "padded" << endl;
    fftw_complex *in, *out; // init the data types fftw needs
    fftw_plan p; // init a plan
    int N = tser.size(); // size of arrays
//    cout << N << endl;
    vector<vector<double> > vect(N/2, vector<double>(3)); // a vector which will hold T4 {f, Re, Im}

    in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // initialize input and output
    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);


    //fill input with h
    for(int i = 0; i < N; i++){
    	in[i][0] = tser[i];
        in[i][1] = 0;       // should be in[i][0] = tser[i];
    }
    p = fftw_plan_dft_1d(N, in, out, FFTW_BACKWARD, FFTW_ESTIMATE); // make the plan
    //compute dft
    fftw_execute(p);
    //deallocate mem from plan
    fftw_destroy_plan(p);
    // make the output a vector
    for(int i = 0; i < N/2; i++){
    	vect[i][0] = (double) i*sr/N;
    	vect[i][1] = out[i][0]*1./sr;
    	vect[i][2] = out[i][1]*1./sr;
    }
    //deallocate memory from in and out
    fftw_free(in); fftw_free(out);

    //assign output to member variable
    h_T4_f = vect;
}

//Return the different h(f) solutions
//downsampled or what have you
// things are structured such that you should
// only ever really have to call these if you want h(f)

vector<vector<double> > TaylorT4::get_hfsol(){
	make_T4();
//	cout << "here get hfsol" << endl;
	return h_T4_f;
}
vector<vector<double> > TaylorT4::get_hfsol_downsamp(double fend, double df_lim){
	make_T4();

//	cout << "T4 initial size = " << h_T4_f.size() << endl;
//	cout << "T4 initial df = " << h_T4_f[1][0] << endl;

	//decide how much to downsample
	int factor = 1;
	double df = h_T4_f[1][0];
	while(df < df_lim){
		factor ++;
		df = h_T4_f[factor][0];
	}
	int downsamp = factor;
	int num_samp = floor(h_T4_f.size()/downsamp);

//	cout << "Downsampled = " << factor << " new df = " << df << " New size = " << num_samp << endl;

	vector<vector<double>> downsamped_T4 (num_samp, vector<double> (3));

//	cout << "Largest access in second loop = " << (num_samp - 1)*downsamp << endl;

	//downsample
	for(int i = 0; i < num_samp; i++){
		downsamped_T4[i][0] = h_T4_f[i*downsamp][0];
		downsamped_T4[i][1] = h_T4_f[i*downsamp][1];
		downsamped_T4[i][2] = h_T4_f[i*downsamp][2];
	}

	//remove anything prior to 10hz
	int i = 0;
	while(downsamped_T4[i][0] < 10){
		downsamped_T4[i][1] = 0;
		downsamped_T4[i][2] = 0;
		i++;
	}

	int j = downsamped_T4.size();
	while(downsamped_T4[j - 1][0] >= fend){
		j--;
	}
	if( j % 2 != 0){
		j--;
	}
	downsamped_T4.resize(j);

	return downsamped_T4;
}
vector<vector<double> > TaylorT4::get_hfsol_downsamp_e(double fend, double df_lim){
	make_T4_e();


	//decide how much to downsample
	int factor = 1;
	double df = h_T4_f[1][0];
	while(df < df_lim){
		factor ++;
		df = h_T4_f[factor][0];
	}
	int downsamp = factor;
	int num_samp = floor(h_T4_f.size()/downsamp);

	vector<vector<double>> downsamped_T4 (num_samp, vector<double> (3));

	//downsample
	for(int i = 0; i < num_samp; i++){
		downsamped_T4[i][0] = h_T4_f[i*downsamp][0];
		downsamped_T4[i][1] = h_T4_f[i*downsamp][1];
		downsamped_T4[i][2] = h_T4_f[i*downsamp][2];
	}

	//remove anything prior to 10hz
	int i = 0;
	while(downsamped_T4[i][0] < 10){
		downsamped_T4[i][1] = 0;
		downsamped_T4[i][2] = 0;
		i++;
	}

	int j = downsamped_T4.size();
	while(downsamped_T4[j - 1][0] >= fend){
		j--;
	}
	if( j % 2 != 0){
		j--;
	}
	downsamped_T4.resize(j);

	return downsamped_T4;
}
vector<vector<double> > TaylorT4::get_hfsol_pn(int pn){
	make_T4_pn(pn);
//	cout << "here get hfsol" << endl;
	return h_T4_f;
}
vector<vector<double> > TaylorT4::get_hfsol_e(){
	make_T4_e();
//	cout << "here get hfsol" << endl;
	return h_T4_f;
}
vector<vector<double> > TaylorT4::get_hfsol(int ncyc){
	make_T4(ncyc);
//	cout << "here get hfsol" << endl;
	return h_T4_f;
}

////////////////////////////////////////////////////////////////////////////////
// Below provides the harmonic amplitudes
////////////////////////////////////////////////////////////////////////////////

double TaylorT4::amplookup_j(double y, double e, double eta, int j){
	double fac = 1.0;
	if (j == 1){
		return fac*N_p_1_e_20(y, e, eta);
	} else if (j == 0) {
		return fac*N_0_e_20(y, e, eta);
	} else if (j == -1) {
		return fac*N_m_1_e_20(y, e, eta);
	} else if (j == 2) {
		return fac*N_p_2_e_20(y, e, eta);
	} else if (j == 3) {
		return fac*N_p_3_e_20(y, e, eta);
	} else if (j == 4) {
		return fac*N_p_4_e_20(y, e, eta);
	} else if (j == 5) {
		return fac*N_p_5_e_20(y, e, eta);
	} else if (j == 6) {
		return fac*N_p_6_e_20(y, e, eta);
	} else if (j == 7) {
		return fac*N_p_7_e_20(y, e, eta);
	} else if (j == 8) {
		return fac*N_p_8_e_20(y, e, eta);
	} else if (j == 9) {
		return fac*N_p_9_e_20(y, e, eta);
	} else if (j == 10) {
		return fac*N_p_10_e_20(y, e, eta);
	} else if (j == 11) {
		return fac*N_p_11_e_20(y, e, eta);
	} else if (j == 12) {
		return fac*N_p_12_e_20(y, e, eta);
	} else if (j == 13) {
		return fac*N_p_13_e_20(y, e, eta);
	} else if (j == 14) {
		return fac*N_p_14_e_20(y, e, eta);
	} else if (j == 15) {
		return fac*N_p_15_e_20(y, e, eta);
	} else if (j == -3) {
		return fac*N_m_3_e_20(y, e, eta);
	} else if (j == -4) {
		return fac*N_m_4_e_20(y, e, eta);
	} else if (j == -5) {
		return fac*N_m_5_e_20(y, e, eta);
	} else if (j == -6) {
		return fac*N_m_6_e_20(y, e, eta);
	} else if (j == -7) {
		return fac*N_m_7_e_20(y, e, eta);
	} else if (j == -8) {
		return fac*N_m_8_e_20(y, e, eta);
	} else if (j == -9) {
		return fac*N_m_9_e_20(y, e, eta);
	} else if (j == -10) {
		return fac*N_m_10_e_20(y, e, eta);
	} else if (j == -11) {
		return fac*N_m_11_e_20(y, e, eta);
	} else if (j == -12) {
		return fac*N_m_12_e_20(y, e, eta);
	} else if (j == -13) {
		return fac*N_m_13_e_20(y, e, eta);
	} else if (j == -14) {
		return fac*N_m_14_e_20(y, e, eta);
	} else if (j == -15) {
		return fac*N_m_15_e_20(y, e, eta);
	} else { cout << "Index error looking up harmonics j" << endl;
	return 0;}
}

//////////////////////////////////////////////////////////////////////
// The harmonic decomposition of h(t) at 0PN in the amplitude but
// at 3PN in the phasing which leads to the decomposition
// i.e. 3PN in W(l)
//////////////////////////////////////////////////////////////////////

double TaylorT4::H_harmdecomp_j(double y, double e, double l, double lam, int j){
	double ampj = amplookup_j(y, e, eta, j);
//	double ampj = 1.0;
	double hplus;
	double hcross;
	double h;

	hplus = - (1.+cos(iota)*cos(iota))*cos(j*l + 2*lam)*ampj;
	hcross = -2*cos(iota)*sin(j*l + 2*lam)*ampj;
	h = M*eta/DL*y*y*(1-e*e)*(hplus*F_p(thet, phi, psi) + hcross*F_c(thet, phi, psi));
//	h = M*eta/DL*(hplus*F_p(thet, phi, psi) + hcross*F_c(thet, phi, psi));

	return h;
}
double TaylorT4::amplookup_n(double e, int n){
	if (n == 1){
		return G_1_e_20(e);
	} else if (n == 2){
		return G_2_e_20(e);
	} else if (n == 3){
		return G_3_e_20(e);
	} else if (n == 4){
		return G_4_e_20(e);
	} else if (n == 5){
		return G_5_e_20(e);
	} else if (n == 6){
		return G_6_e_20(e);
	} else if (n == 7){
		return G_7_e_20(e);
	} else if (n == 8){
		return G_8_e_20(e);
	} else if (n == 9){
		return G_9_e_20(e);
	} else if (n == 10){
		return G_10_e_20(e);
	} else if (n == 11){
		return G_11_e_20(e);
	} else if (n == 12){
		return G_12_e_20(e);
	} else if (n == 13){
		return G_13_e_20(e);
	} else if (n == 14){
		return G_14_e_20(e);
	} else if (n == 15){
		return G_15_e_20(e);
	} else {
		cout << "Index error looking up harmonics n" << endl;
		return 0;
	}
}
double TaylorT4::H_harmdecomp_n(double y, double e, double l, int n){
	double ampn = amplookup_n( e, n);
//	double ampj = 1.0;
	double hplus;
	double hcross;
	double h;

	hplus = sin(iota)*sin(iota)*cos(n*l)*ampn;
	hcross = 0;
	h = M*eta/DL*y*y*(1-e*e)*(hplus*F_p(thet, phi, psi) + hcross*F_c(thet, phi, psi));
//	h = M*eta/DL*(hplus*F_p(thet, phi, psi) + hcross*F_c(thet, phi, psi));

	return h;
}

double TaylorT4::H_harmdecomp(double y, double e, double l, double lam)
{
	double N0 = 0, Np1 = 0, Np2 = 0, Np3 = 0, Np4 = 0, Np5 = 0, Np6 = 0, Np7 = 0, Np8 = 0, Np9 = 0, Np10 = 0, Np11 = 0, Np12 = 0, Np13 = 0,
			Np14 = 0, Np15 = 0, Nm1 = 0, Nm2 = 0, Nm3 = 0, Nm4 = 0, Nm5 = 0, Nm6 = 0, Nm7 = 0, Nm8 = 0, Nm9 = 0, Nm10 = 0, Nm11 = 0, Nm12 = 0, Nm13 = 0, Nm14 = 0, Nm15 = 0;
	double G1 = 0, G2 = 0, G3 = 0, G4 = 0, G5 = 0, G6 = 0, G7 = 0, G8 = 0, G9 = 0, G10 = 0, G11 = 0, G12 = 0, G13 = 0, G14 = 0, G15 = 0;
		N0 = N_0_e_20(y, e, eta);
		Np1 = N_p_1_e_20(y, e, eta);
		Np2 = N_p_2_e_20(y, e, eta);
		Np3 = N_p_3_e_20(y, e, eta);
		Np4 = N_p_4_e_20(y, e, eta);
		Np5 = N_p_5_e_20(y, e, eta);
		Np6 = N_p_6_e_20(y, e, eta);
		Np7 = N_p_7_e_20(y, e, eta);
		Np8 = N_p_8_e_20(y, e, eta);
		Np9 = N_p_9_e_20(y, e, eta);
		Np10 = N_p_10_e_20(y, e, eta);
		Np11 = N_p_11_e_20(y, e, eta);
		Np12 = N_p_12_e_20(y, e, eta);
		Np13 = N_p_13_e_20(y, e, eta);
		Np14 = N_p_14_e_20(y, e, eta);
		Np15 = N_p_15_e_20(y, e, eta);
		Nm1 = N_m_1_e_20(y, e, eta);
		Nm2 = N_m_2_e_20(y, e, eta);
		Nm3 = N_m_3_e_20(y, e, eta);
		Nm4 = N_m_4_e_20(y, e, eta);
		Nm5 = N_m_5_e_20(y, e, eta);
		Nm6 = N_m_6_e_20(y, e, eta);
		Nm7 = N_m_7_e_20(y, e, eta);
		Nm8 = N_m_8_e_20(y, e, eta);
		Nm9 = N_m_9_e_20(y, e, eta);
		Nm10 = N_m_10_e_20(y, e, eta);
		Nm11 = N_m_11_e_20(y, e, eta);
		Nm12 = N_m_12_e_20(y, e, eta);
		Nm13 = N_m_13_e_20(y, e, eta);
		Nm14 = N_m_14_e_20(y, e, eta);
		Nm15 = N_m_15_e_20(y, e, eta);
		G1 = G_1_e_20(e);
		G2 = G_2_e_20(e);
		G3 = G_3_e_20(e);
		G4 = G_4_e_20(e);
		G5 = G_5_e_20(e);
		G6 = G_6_e_20(e);
		G7 = G_7_e_20(e);
		G8 = G_8_e_20(e);
		G9 = G_9_e_20(e);
		G10 = G_10_e_20(e);
		G11 = G_11_e_20(e);
		G12 = G_12_e_20(e);
		G13 = G_13_e_20(e);
		G14 = G_14_e_20(e);
		G15 = G_15_e_20(e);
	double hplus;
	double hcross;
	double h;

	hplus = sin(iota)*sin(iota)*(cos(l)*G1 + cos(2*l)*G2 + cos(3*l)*G3 + cos(4*l)*G4 + cos(5*l)*G5 + cos(6*l)*G6 + cos(7*l)*G7 + cos(8*l)*G8 + cos(9*l)*G9 + cos(10*l)*G10 + cos(11*l)*G11 + cos(12*l)*G12 + cos(13*l)*G13 + cos(14*l)*G14
			 + cos(15*l)*G15) - (1.+cos(iota)*cos(iota))*(cos(2*lam)*N0 + cos(l+2*lam)*Np1 + cos(2*l+2*lam)*Np2 + cos(3*l+2*lam)*Np3 + cos(4*l+2*lam)*Np4 + cos(5*l+2*lam)*Np5 + cos(6*l+2*lam)*Np6 + cos(7*l+2*lam)*Np7
			 + cos(8*l+2*lam)*Np8 + cos(9*l+2*lam)*Np9 + cos(10*l+2*lam)*Np10 + cos(11*l+2*lam)*Np11 + cos(12*l+2*lam)*Np12 + cos(13*l+2*lam)*Np13 + cos(14*l+2*lam)*Np14 + cos(15*l+2*lam)*Np15
			 + cos(-l+2*lam)*Nm1 + cos(-2*l+2*lam)*Nm2 + cos(-3*l+2*lam)*Nm3 + cos(-4*l+2*lam)*Nm4 + cos(-5*l+2*lam)*Nm5 + cos(-6*l+2*lam)*Nm6 + cos(-7*l+2*lam)*Nm7
			 + cos(-8*l+2*lam)*Nm8 + cos(-9*l+2*lam)*Nm9 + cos(-10*l+2*lam)*Nm10 + cos(-11*l+2*lam)*Nm11 + cos(-12*l+2*lam)*Nm12 + cos(-13*l+2*lam)*Nm13 + cos(-14*l+2*lam)*Nm14 + cos(-15*l+2*lam)*Nm15);

	hcross = -2*cos(iota)*(sin(2*lam)*N0 + sin(l+2*lam)*Np1 + sin(2*l+2*lam)*Np2 + sin(3*l+2*lam)*Np3 + sin(4*l+2*lam)*Np4 + sin(5*l+2*lam)*Np5 + sin(6*l+2*lam)*Np6 + sin(7*l+2*lam)*Np7 + sin(8*l+2*lam)*Np8
			 + sin(9*l+2*lam)*Np9 + sin(10*l+2*lam)*Np10 + sin(11*l+2*lam)*Np11 + sin(12*l+2*lam)*Np12 + sin(13*l+2*lam)*Np13 + sin(14*l+2*lam)*Np14 + sin(15*l+2*lam)*Np15 + sin(-l+2*lam)*Nm1 + sin(-2*l+2*lam)*Nm2
			 + sin(-3*l+2*lam)*Nm3 + sin(-4*l+2*lam)*Nm4 + sin(-5*l+2*lam)*Nm5 + sin(-6*l+2*lam)*Nm6 + sin(-7*l+2*lam)*Nm7 + sin(-8*l+2*lam)*Nm8 + sin(-9*l+2*lam)*Nm9 + sin(-10*l+2*lam)*Nm10 + sin(-11*l+2*lam)*Nm11
			 + sin(-12*l+2*lam)*Nm12 + sin(-13*l+2*lam)*Nm13 + sin(-14*l+2*lam)*Nm14 + sin(-15*l+2*lam)*Nm15);

	h = M*eta/DL*y*y*(1-e*e)*(hplus*F_p(thet, phi, psi) + hcross*F_c(thet, phi, psi));

	return h;
}
double TaylorT4::get_df(){
	return h_T4_f[1][0] - h_T4_f[0][0];
}

////////////////////////////////////////
// Some useful nonmember functions
// padding and simple inner products
////////////////////////////////////////

vector<double> pad_h_nonmem(vector<double> ht){
	int N = ht.size();
	int K = pow(2, ceil(log2((double) N)));
	int padL = ceil((double) (K-N)/2);
	vector<double> paddedht (K);

	for(int i = padL - 1; i < ht.size() + padL - 1 ; i++){
		paddedht[i] = ht[i - (padL - 1)];
	}
	return paddedht;
}
vector<vector<double> > make_T4_nonmem(vector<double> ht, int sr){
	vector<double> tser = pad_h_nonmem(ht);
    fftw_complex *in, *out; // init the data types fftw needs
    fftw_plan p; // init a plan
    int N = tser.size(); // size of arrays
    vector<vector<double> > vect(N/2, vector<double>(3)); // a vector which will hold T4 {f, Re, Im}

    in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // initialize input and output
    out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N);


    //fill input with h
    for(int i = 0; i < N; i++){
    	in[i][0] = tser[i];
        in[i][1] = 0;       // should be in[i][0] = tser[i];
    }
    p = fftw_plan_dft_1d(N, in, out, FFTW_BACKWARD, FFTW_ESTIMATE); // make the plan
    //compute dft
    fftw_execute(p);
    //deallocate mem from plan
    fftw_destroy_plan(p);
    // make the output a vector
    for(int i = 0; i < N/2; i++){
    	vect[i][0] = (double) i*sr/N;
    	vect[i][1] = out[i][0]*1./sr;
    	vect[i][2] = out[i][1]*1./sr;
    }
    //deallocate memory from in and out
    fftw_free(in); fftw_free(out);

    //assign output to member variable
    return vect;
}
vector<vector<double> > TaylorT4::make_T4_decomp(){
	vector<double> time_dom_decomp (ysol.size());
	for(int i = 0; i < time_dom_decomp.size(); i++){
		time_dom_decomp[i] = H_harmdecomp(ysol[i], esol[i], lsol[i], lamsol[i]);
	}
	return make_T4_nonmem(time_dom_decomp, 8192);
}

vector<vector<double> > TaylorT4::make_T4_decomp(int j){
	vector<double> time_dom_decomp (ysol.size());
	for(int i = 0; i < time_dom_decomp.size(); i++){
		time_dom_decomp[i] = H_harmdecomp_j(ysol[i], esol[i], lsol[i], lamsol[i], j);
	}
	return make_T4_nonmem(time_dom_decomp, sr);
}
vector<vector<double> > TaylorT4::make_T4_decomp_n(int n){
	vector<double> time_dom_decomp (ysol.size());
	for(int i = 0; i < time_dom_decomp.size(); i++){
		time_dom_decomp[i] = H_harmdecomp_n(ysol[i], esol[i], lsol[i], n);
	}
	return make_T4_nonmem(time_dom_decomp, sr);
}
double innerprod(vector<vector<double> > h1, vector<vector<double> > h2, vector<double> noise){
	double sum = 0;

	for(int i = 0; i < h1.size(); i++){
		if(h1[i][0] > 1 && h1[i][0] < 4096){
			sum += (h1[i][1]*h2[i][1]+h1[i][2]*h2[i][2])/exp(noise[i]);
		} else {
			sum += 0;
		}
	}

	return 4*sum;
}
double overlap(vector<vector<double> > h1, vector<vector<double> > h2, vector<double> noise){
	double snr1;
	double snr2;
	double prod;

	snr1 = innerprod(h1, h1, noise);
	snr2 = innerprod(h2, h2, noise);
	prod = innerprod(h1, h2, noise);

	return prod/Bpow(snr1*snr2, 1./2.);
}
void write_vec(vector<double> vect, string str){
	ofstream out;
	out.open(str);
    for (int i=0; i<vect.size(); i++){
    out << setprecision(16) << ' ' << vect[i] << endl;
    }
    out.close();
}
